<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Windows内部 | deCOLE's Blog</title><meta name="author" content="deCOLE"><meta name="copyright" content="deCOLE"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Windows内部">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows内部">
<meta property="og:url" content="http://example.com/2025/03/18/Windows%E5%86%85%E9%83%A8/index.html">
<meta property="og:site_name" content="deCOLE&#39;s Blog">
<meta property="og:description" content="Windows内部">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/touxiang.jpg">
<meta property="article:published_time" content="2025-03-17T16:00:00.000Z">
<meta property="article:modified_time" content="2025-03-18T05:58:20.042Z">
<meta property="article:author" content="deCOLE">
<meta property="article:tag" content="TryHackMe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/touxiang.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Windows内部",
  "url": "http://example.com/2025/03/18/Windows%E5%86%85%E9%83%A8/",
  "image": "http://example.com/img/touxiang.jpg",
  "datePublished": "2025-03-17T16:00:00.000Z",
  "dateModified": "2025-03-18T05:58:20.042Z",
  "author": [
    {
      "@type": "Person",
      "name": "deCOLE",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/touxiang.jpg"><link rel="canonical" href="http://example.com/2025/03/18/Windows%E5%86%85%E9%83%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Windows内部',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(img/qccq.jpg);"></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">deCOLE's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Windows内部</span></a></span><div id="menus"></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Windows内部</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-17T16:00:00.000Z" title="发表于 2025-03-18 00:00:00">2025-03-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-18T05:58:20.042Z" title="更新于 2025-03-18 13:58:20">2025-03-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h2 id="Windows内部"><a href="#Windows内部" class="headerlink" title="Windows内部"></a>Windows内部</h2><h4 id="进程（Processes）"><a href="#进程（Processes）" class="headerlink" title="进程（Processes）"></a>进程（Processes）</h4><p>每个进程都提供执行程序所需要的资源</p>
<p>进程具有虚拟空间、可执行代码、系统对象的开放句柄、安全上下文、唯一进程标识符、环境变量、优先级类、最小和最大工作及大小、至少一个执行线程</p>
<p>每个进程都用单个线程（通常称为<strong>主线程</strong>）启动，但可以从其任何线程创建其他线程</p>
<table>
<thead>
<tr>
<th>进程组件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>私有虚拟地址空间</td>
<td>为进程分配虚拟内存地址</td>
</tr>
<tr>
<td>可执行程序</td>
<td>定义存储在虚拟地址空间中的代码和数据</td>
</tr>
<tr>
<td>开放句柄</td>
<td>定义进程可以访问的系统资源的句柄</td>
</tr>
<tr>
<td>安全上下文</td>
<td>访问令牌，定义用户、权限和其他安全信息</td>
</tr>
<tr>
<td>进程ID</td>
<td>进程的唯一数字标识符</td>
</tr>
<tr>
<td>线程</td>
<td>计划执行的进程部分</td>
</tr>
</tbody></table>
<p>从更底层的层面来看，也就是从虚拟地址空间一层面来解释进程</p>
<p>进程在内存中的组件和用途大概如下</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>代码(Code)</td>
<td>提供进程执行的代码</td>
</tr>
<tr>
<td>全局变量(Global Variables)</td>
<td>存储的变量</td>
</tr>
<tr>
<td>进程堆（Process Heap）</td>
<td>定义数据存储的堆</td>
</tr>
<tr>
<td>进程资源(Process Resources)</td>
<td>定义进程的更多资源</td>
</tr>
<tr>
<td>环境块（Environment Block）</td>
<td>用于定义进程信息的数据结构</td>
</tr>
</tbody></table>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412291429154.png?raw=true" alt="image-20241229142920993"></p>
<p>在任务管理器中的进程信息有这些</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>作用</th>
<th>例</th>
</tr>
</thead>
<tbody><tr>
<td>Name</td>
<td>定义进程的名称，通常从应用程序处继承而来</td>
<td>conhost.exe</td>
</tr>
<tr>
<td>PID</td>
<td>用于标识进程的唯一数值</td>
<td>7408</td>
</tr>
<tr>
<td>Status</td>
<td>确定进程的运行方式（正在运行、已挂起等）</td>
<td>Running</td>
</tr>
<tr>
<td>User name</td>
<td>启动进程的用户。也可表示进程的权限</td>
<td>SYSTEM</td>
</tr>
</tbody></table>
<h4 id="线程（Threads）"><a href="#线程（Threads）" class="headerlink" title="线程（Threads）"></a>线程（Threads）</h4><p>线程是<strong>进程内可计划执行的实体</strong></p>
<p>进程的所有线程共享其虚拟地址空间和系统资源</p>
<p>每个线程都维护异常处理程序、计划优先级、线程本地存储、唯一线程标识符，以及系统将用于保存线程上下文的一组结构，直到计划线程上下文为止</p>
<p><em>线程上下文包括：线程的计算机的寄存器集、内核堆栈、线程环境块，以及线程进程的地址空间中的用户堆栈</em></p>
<p>线程还可以有自己的安全上下文，可用于模拟客户端</p>
<p>Windows支持 <em><strong>抢占式多任务处理</strong></em>  ，这将会产生同时执行多个进程中多个线程的效果。在多处理器计算机上，系统可以同时执行与计算机上存在的处理器一样多的线程</p>
<p>用一句话可以概括线程的作用：<strong>控制进程的进行</strong></p>
<p>进程的组成大致如下</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>栈（Stack）</td>
<td>与线程相关且特定于线程的所有数据（异常、过程调用等）</td>
</tr>
<tr>
<td>线程本地存储（Thread Local Storage）</td>
<td>用于为唯一数据环境分配存储空间的指针</td>
</tr>
<tr>
<td>栈参数（Stack Argument）</td>
<td>分配给每个线程的唯一值</td>
</tr>
<tr>
<td>上下文结构（Context Structure）</td>
<td>保护由内核维护的机器寄存器值</td>
</tr>
</tbody></table>
<h4 id="虚拟内存（Virtual-Memory）"><a href="#虚拟内存（Virtual-Memory）" class="headerlink" title="虚拟内存（Virtual Memory）"></a>虚拟内存（Virtual Memory）</h4><p>虚拟内存是Windows内部工作原理的一个重要组成部分</p>
<p>虚拟内存允许其他内部组件与内存交互，就像物理内存一样，但不会有应用程序之间发生冲突的风险</p>
<p>虚拟内存为每个进程都提供了一个<strong>专用虚拟地址空间</strong>。而内存管理器则用于将虚拟地址转换为物理地址</p>
<p>通过拥有私有虚拟地址空间，而不是直接写入物理内存，能减小进程对内存造成的损害风险</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412291553259.png?raw=true" alt="image-20241229155344086"></p>
<p>内存管理器也会使用 <strong>页(Page)</strong> 或者 **交换 (Transfer)**操作来管理内存</p>
<p>应用程序使用的虚拟内存，可能会超过已分配的物理内存。为了解决这个问题，内存管理器会把虚拟内存交换或分页到磁盘上，就像上图一样</p>
<ul>
<li>在32位x86系统上，理论上最大虚拟地址空间为4 GB</li>
<li>在64位现代系统上，理论上最大虚拟地址空间为256 TB</li>
</ul>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412291557031.png?raw=true" alt="image-20241229155707886"></p>
<p>地址空间被分为上下两个部分</p>
<p>下半部分（<em>0x00000000 - 0x7FFFFFFF</em>）分配给进程</p>
<p>上半部分（<em>0x80000000 - 0xFFFFFFFF</em>）分配给操作系统内存利用</p>
<p>管理员可以通过设置（increaseUserVA）或使用 AWE（Address Windowing Extensions）来改变这种分配布局，以满足需要更大地址空间的应用程序。</p>
<h4 id="动态链接库（DLL）"><a href="#动态链接库（DLL）" class="headerlink" title="动态链接库（DLL）"></a>动态链接库（DLL）</h4><p><strong>Dynamic Link Libraries</strong>——动态链接库，简写为DLL</p>
<p>在微软的官方文档中，DLL是”<strong>一个包含代码和数据的库，可供多个程序共同使用</strong>“</p>
<p>由于本人先前略微了解过一些PWN的基础知识，这个DLL按我个人浅薄的理解就类似于一个工具箱，需要的时候就建立相应的依赖</p>
<p>比较官方一点的说法 ：</p>
<p><em>DLL 作为 Windows 应用程序执行背后的核心功能之一。</em></p>
<p><em>根据 Windows 文档 [What is a DLL - Microsoft Learn](<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/troubleshoot/windows-client/deployment/dynamic-link-library#:~:text=A">https://learn.microsoft.com/en-us/troubleshoot/windows-client/deployment/dynamic-link-library#:~:text=A</a> DLL is a library,common dialog box related functions.) ，“使用 DLL 有助于促进代码的模块化、代码重用、高效的内存使用以及减少磁盘空间。</em></p>
<p><em>因此，操作系统和程序加载更快，运行更快，并且在计算机上占用更少的磁盘空间</em></p>
<p>当一个DLL作为程序中的一个函数被加载时，该DLL将会被指定为依赖项</p>
<p>由于程序依赖于DLL，攻击者就可以针对DLL来控制应用程序的执行或者某些方面的功能</p>
<p>例如：</p>
<ul>
<li><p>DLL 劫持（<a target="_blank" rel="noopener" href="https://attack.mitre.org/techniques/T1574/001/">T1574.001</a>）</p>
</li>
<li><p>DLL 侧加载（<a target="_blank" rel="noopener" href="https://attack.mitre.org/techniques/T1574/002/">T1574.002</a>）</p>
</li>
<li><p>DLL 注入（<a target="_blank" rel="noopener" href="https://attack.mitre.org/techniques/T1055/001/">T1055.001</a>）</p>
</li>
</ul>
<p>这是来自Visual C++ Win32 Dynamic-Link Library 项目的 DLL 示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#define EXPORTING_DLL</span><br><span class="line">#include &quot;sampleDLL.h&quot;</span><br><span class="line">BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HelloWorld()</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox(NULL, TEXT(&quot;Hello World&quot;), TEXT(&quot;In a DLL&quot;), MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以下是DLL的头文件，它定义了需要导入和导出的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#ifndef INDLL_H</span><br><span class="line">    #define INDLL_H</span><br><span class="line">    #ifdef EXPORTING_DLL</span><br><span class="line">        extern __declspec(dllexport) void HelloWorld();</span><br><span class="line">    #else</span><br><span class="line">        extern __declspec(dllimport) void HelloWorld();</span><br><span class="line">    #endif</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>



<p>DLL可以使用加载时动态链接货2运行时动态链接，来加载到程序中</p>
<p>使用加载时动态链接时，应用程序会对DLL函数进行显示调用。只有提供了头文件（.h）和导入库（.lib）文件才能实现这种类型的链接。以下是从应用程序调用导出的 DLL 函数的示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sampleDLL.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> APIENTRY <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line">    HelloWorld();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用运行时动态链接时，需要使用单独的函数（<code>LoadLibrary</code> 或 <code>LoadLibraryEx</code>）来在运行时加载 DLL。一旦加载，需要使用 <code>GetProcAddress</code> 来识别要调用的导出 DLL 函数。以下是在应用程序中加载和导入 DLL 函数的示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span> <span class="params">(*DLLPROC)</span> <span class="params">(LPTSTR)</span>;</span><br><span class="line">...</span><br><span class="line">HINSTANCE hinstDLL;</span><br><span class="line">DLLPROC HelloWorld;</span><br><span class="line">BOOL fFreeDLL;</span><br><span class="line"></span><br><span class="line">hinstDLL = LoadLibrary(<span class="string">&quot;sampleDLL.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (hinstDLL != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    HelloWorld = (DLLPROC) GetProcAddress(hinstDLL, <span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (HelloWorld != <span class="literal">NULL</span>)</span><br><span class="line">        (HelloWorld);</span><br><span class="line">    fFreeDLL = FreeLibrary(hinstDLL);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在恶意代码中，威胁行为者通常会比使用加载时动态链接更多地使用运行时动态链接。这是因为恶意程序可能需要在内存区域之间传输文件，并且传输单个 DLL 比使用其他文件要求更容易管理。</p>
<h4 id="可移植可执行文件格式（Portable-Executable-Format-）"><a href="#可移植可执行文件格式（Portable-Executable-Format-）" class="headerlink" title="可移植可执行文件格式（Portable Executable Format ）"></a>可移植可执行文件格式（Portable Executable Format ）</h4><p>可执行文件和应用程序是Windows内部操作的重要组成部分</p>
<p>PE格式定义了关于可执行文件和存储数据的信息，此外，PE格式还定义了数据组件存储结构的方式</p>
<p>PE格式是可执行文件和目标文件的总体结构，PE文件和COFF（通用对象文件格式）文件构成了PE格式</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412291656739.png?raw=true" alt="image-20241229165605582"></p>
<p>PE数据的结构大概可以分为七个部分</p>
<ul>
<li>DOS标头（DOS Header）：定义文件类型，DOS存根（DOS Stub）则是默认在文件开头运行的程序，用于打印兼容性信息。对于大多数用户来说，这不对文件的任何功能产生任何影响</li>
<li>PE文件头（PE File Header）：提供二进制文件的PE Header信息。定义文件格式，包含签名和图像文件头，以及其他信息头</li>
<li>图像可选头部（Image Optional Header）：是PE File Header的重要组成部分，有欺骗性名称（？？？）</li>
<li>数据字典（Data Dictionaries）：是Image Optional  Header的一部分，它们指向图像数据目录结构</li>
<li>节表（Sections Table）：定义图像中的可用截面和信息。节用于存储文件的内容，例如代码、导入项和数据</li>
</ul>
<p>既然文件头已经定义了文件的格式和功能，各个节就能定义文件的内容和数据了</p>
<table>
<thead>
<tr>
<th>节（Section）</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>.text</td>
<td>包含可执行代码和入口点</td>
</tr>
<tr>
<td>.data</td>
<td>包含已初始化的数据（字符串、变量等）</td>
</tr>
<tr>
<td>.rdata或.idata</td>
<td>包含导入项（Windows API）和动态链接库（DLL）</td>
</tr>
<tr>
<td>.reloc</td>
<td>包含重定位信息</td>
</tr>
<tr>
<td>.rsrc</td>
<td>包含应用程序资源（图像等）</td>
</tr>
<tr>
<td>.debug</td>
<td>包含调试信息</td>
</tr>
</tbody></table>
<h4 id="与Windows内部交互"><a href="#与Windows内部交互" class="headerlink" title="与Windows内部交互"></a>与Windows内部交互</h4><p>Windows内核将控制所有程序和进程，并桥接所有软件和硬件交互</p>
<p>默认情况下，应用程序通常无法与内核交互或者修改物理硬件，需要一个接口。这个问题，Windows用处理器模式和访问级别来解决</p>
<p>Windows处理器具有<strong>用户模式</strong>和<strong>内核模式</strong>，处理器将根据访问和请求的模式，在这两个模式之间切换</p>
<p>用户模式和内核模式之间的切换通常由系统和API调用来实现，在文档中，这个点有时候被称为<strong>切换点（<em>Switching Point</em>）</strong></p>
<table>
<thead>
<tr>
<th>用户模式</th>
<th>内核模式</th>
</tr>
</thead>
<tbody><tr>
<td>无法直接访问硬件</td>
<td>可直接访问硬件</td>
</tr>
<tr>
<td>在私有虚拟地址空间中创建进程</td>
<td>在单个共享虚拟地址空间中运行</td>
</tr>
<tr>
<td>只能访问“所属内存位置”</td>
<td>可访问整个物理内存</td>
</tr>
</tbody></table>
<p>在<strong>用户模式</strong> 或 <strong>用户空间</strong> 中启动的应用程序将保持该模式，直到通过API进行系统调用或交互。</p>
<p>进行系统调用时，应用程序将切换模式</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412300930042.png?raw=true" alt="image-20241230093041888"></p>
<p>我们将在本地进程中注入一个消息框，用以演示内存交互</p>
<p>将消息框写入内存的步骤大概如下：</p>
<ul>
<li>为消息框分配本地进程内存</li>
<li>将消息框写入&#x2F;复制到分配的内存</li>
<li>从本地进程内存执行消息框</li>
</ul>
<p>对于第一步，我们可以使用<code>OpenProcess</code>来获取指定进程的句柄</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 尝试打开一个指定进程，返回一个进程句柄</span><br><span class="line">HANDLE hProcess = OpenProcess(</span><br><span class="line">    PROCESS_ALL_ACCESS, // 定义对目标进程的访问权限，这里请求所有可能的访问权限</span><br><span class="line">    FALSE, // 表示打开的目标进程句柄不会被子进程继承</span><br><span class="line">    DWORD(atoi(argv[1])) // 通过命令行参数获取要打开的本地进程的ID。</span><br><span class="line">                          // atoi函数将命令行参数（字符串形式）转换为整数，再转换为DWORD类型作为进程ID</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>对于第二步，我们可以用payload buffer来分配内存区域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 在目标进程的地址空间中分配内存，并返回分配内存区域的起始地址</span><br><span class="line">LPVOID remoteBuffer = VirtualAllocEx(</span><br><span class="line">    hProcess, // 已打开的目标进程句柄，指定要在哪个进程的地址空间中分配内存</span><br><span class="line">    NULL,     // 通常设为 NULL，表示让系统决定分配内存的起始地址</span><br><span class="line">    sizeof(payload), // 要分配的内存区域大小，这里使用了名为 payload 的对象的大小</span><br><span class="line">    (MEM_RESERVE | MEM_COMMIT), // 分配类型，同时进行内存保留和提交操作</span><br><span class="line">                                // MEM_RESERVE：保留指定大小的地址空间，但不实际分配物理内存</span><br><span class="line">                                // MEM_COMMIT：为保留的地址空间分配物理内存</span><br><span class="line">    PAGE_EXECUTE_READWRITE // 内存保护属性，允许对提交的页面进行执行、读取和写入操作</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>第三步：将payload写入分配的内存区域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// WriteProcessMemory函数用于将数据写入到另一个进程的内存空间中</span><br><span class="line">// 以下是对其参数的详细解释</span><br><span class="line">BOOL writeResult = WriteProcessMemory(</span><br><span class="line">    hProcess, // 已打开的目标进程句柄，指定要写入数据的进程</span><br><span class="line">    remoteBuffer, // 目标进程中已分配的内存区域地址，数据将被写入到此地址开始的内存空间</span><br><span class="line">    payload, // 要写入目标进程内存的数据，这里是一个自定义的数据块</span><br><span class="line">    sizeof(payload), // 要写入的数据大小（以字节为单位），明确了写入数据的长度</span><br><span class="line">    NULL // 用于接收实际写入字节数的变量指针，这里设置为NULL表示不关心实际写入的字节数</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>最后一步：从内存中执行payload</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// CreateRemoteThread函数用于在指定的远程进程中创建一个新线程</span><br><span class="line">// 以下是对其各个参数的详细注释</span><br><span class="line">HANDLE remoteThread = CreateRemoteThread(</span><br><span class="line">    hProcess, // 已打开的目标进程句柄，表明要在哪个进程中创建新线程</span><br><span class="line">    NULL,     // 指向SECURITY_ATTRIBUTES结构体的指针，用于指定新线程的安全属性。</span><br><span class="line">              // 设置为NULL时，新线程将使用默认的安全描述符，并且返回的句柄不能被子进程继承</span><br><span class="line">    0,        // 为新线程分配的栈空间大小（以字节为单位）。</span><br><span class="line">              // 设置为0时，系统会为线程分配默认大小的栈空间</span><br><span class="line">    (LPTHREAD_START_ROUTINE)remoteBuffer, // 指向线程函数的指针，该线程函数将在新创建的线程中执行。</span><br><span class="line">                                          // 这里将之前在目标进程中分配内存的地址（remoteBuffer）强制转换为LPTHREAD_START_ROUTINE类型，</span><br><span class="line">                                          // 意味着在这个地址处的代码将作为新线程的起始执行点</span><br><span class="line">    NULL,     // 传递给线程函数的参数。这里设置为NULL，表示线程函数不需要额外的参数</span><br><span class="line">    0,        // 线程创建标志。设置为0时，线程在创建后立即开始执行</span><br><span class="line">    NULL      // 用于接收新线程标识符的变量指针。设置为NULL表示不获取新线程的标识符</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">deCOLE</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/18/Windows%E5%86%85%E9%83%A8/">http://example.com/2025/03/18/Windows%E5%86%85%E9%83%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">deCOLE's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/TryHackMe/">TryHackMe</a></div><div class="post-share"><div class="social-share" data-image="/img/touxiang.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/18/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/" title="Windows权限维持"><img class="cover" src="/img/twjr.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Windows权限维持</div></div><div class="info-2"><div class="info-item-1">Windows权限维持篡改非特权账户分配组成员资格​	在这部分任务中，我们假设的前提是：攻击者已经转储了受害者机器的hash,并成功破解了所使用的非特权账户的密码 使得非特权用户能获得管理权限的最直接的方法就是:使其成为Administrators组的一部分 命令如下： 1net localgroup administrators thmuser0 /add   这将允许我们使用RDP、WinRM或者其他任何可用的远程管理服务，来访问服务器 为了降低可疑程度，可用Backup Operators组 此组中的用户将没有管理权限，但是可用读取、写入系统上的任何文件或注册表项，并且忽略任何已配置的DACL。这样我们就可以复制SAM和SYSTEM注册表配置单元的内容，然后恢复所有用户的密码hash，从而使得我们能升到Administrator 在此之前首先我们要将账户添加到Backup Operators组 1C:\&gt; net localgroup &quot;Backup Operators&quot; thmuser1...</div></div></div></a><a class="pagination-related" href="/2025/03/18/Windows%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/" title="Windows权限提升"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Windows权限提升</div></div><div class="info-2"><div class="info-item-1">Windows权限提升常见获取密码方式无人值守的 Windows 安装在大量主机上安装 Windows 时，管理员可以使用 Windows 部署服务，该服务允许通过网络将单个操作系统映像部署到多个主机。这些类型的安装称为无人值守安装，因为它们不需要用户交互。此类安装需要使用管理员帐户执行初始设置，最终可能会存储在计算机的以下位置： 12345目录:\无人参与.xmlC:\Windows\Panther\Unattend.xmlC:\Windows\Panther\Unattend\Unattend.xml系统信息文件夹:\Windows\system32\sysprep.infC:\Windows\system32\sysprep\sysprep.xml  作为这些文件的一部分，您可能会遇到凭证： 12345&lt;Credentials&gt;    &lt;Username&gt;Administrator&lt;/Username&gt;    &lt;Domain&gt;thm.local&lt;/Domain&gt;   ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/05/19/TryHackMe%E6%88%BF%E9%97%B4%E4%B9%8BBilling/" title="TryHackMe房间之Billing"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-19</div><div class="info-item-2">TryHackMe房间之Billing</div></div><div class="info-2"><div class="info-item-1">TryHackMe房间之Billing总结从没见过的fail2ban提权，不过倒是启发了以后寻找提权点的思路 找一些自己有权限修改，且以高权限用户身份运行的文件或者服务 流程记录扫端口情况如下  对80端口扫描目录 只扫到个robots.txt  直接访问页面，发现就在&#x2F;mbilling下，于是dirsearch再扫一下  找到一个readme  在readme里面找到了版本号  搜索发现存在历史漏洞 https://github.com/tinashelorenzi/CVE-2023-30258-magnus-billing-v7-exploit 用exp直接拿到shell  找到user.txt，在&#x2F;home&#x2F;magnus下  接下来就是权限提升的环节 先sudo -l查看一下  发现我们能够以root权限执行fail2ban Fail2ban是一个入侵防御软件框架。Fail2Ban...</div></div></div></a><a class="pagination-related" href="/2025/05/19/TryHackMe%E6%88%BF%E9%97%B4%E4%B9%8BEnterprise/" title="TryHackMe房间之Enterprise"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-19</div><div class="info-item-2">TryHackMe房间之Enterprise</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2025/05/19/TryHackMe%E6%88%BF%E9%97%B4%E4%B9%8BReset/" title="TryHackMe房间之Reset"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-19</div><div class="info-item-2">TryHackMe房间之Reset</div></div><div class="info-2"><div class="info-item-1">TryHackMe房间之Reset总结对smb还是有点不熟悉，没想到这个smb共享也能打一波强制身份验证来获取哈希，学到了 还有就是bloodhound的使用不够熟练 流程记录rustscan扫描结果如下  enum4linux 枚举发现  用crackmapexec枚举smb，发现域名  添加到&#x2F;etc&#x2F;hosts中 再用smbclient枚举一下  用空密码尝试连接，发现Data下的onboarding文件夹有一些文件  下载到本地  发现里面是一些介绍公司相关的？英语不太好  在第一个pdf里面看到了一个欢迎的email内容示例，得到初始密码：RessetMe123!  所以接下来的思路应该就是：枚举用户然后用初始密码进行密码喷洒 这里靶机中断了，因此ip变动一下 注意到共享文件夹里面的文件会发生变动，这意味着域内用户会访问这个共享文件夹  于是我们便可以在这个文件夹中添加一个恶意文件，用户在读取文件时进行强制身份验证，以此来获取ntlm...</div></div></div></a><a class="pagination-related" href="/2025/03/18/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/" title="Windows权限维持"><img class="cover" src="/img/twjr.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-18</div><div class="info-item-2">Windows权限维持</div></div><div class="info-2"><div class="info-item-1">Windows权限维持篡改非特权账户分配组成员资格​	在这部分任务中，我们假设的前提是：攻击者已经转储了受害者机器的hash,并成功破解了所使用的非特权账户的密码 使得非特权用户能获得管理权限的最直接的方法就是:使其成为Administrators组的一部分 命令如下： 1net localgroup administrators thmuser0 /add   这将允许我们使用RDP、WinRM或者其他任何可用的远程管理服务，来访问服务器 为了降低可疑程度，可用Backup Operators组 此组中的用户将没有管理权限，但是可用读取、写入系统上的任何文件或注册表项，并且忽略任何已配置的DACL。这样我们就可以复制SAM和SYSTEM注册表配置单元的内容，然后恢复所有用户的密码hash，从而使得我们能升到Administrator 在此之前首先我们要将账户添加到Backup Operators组 1C:\&gt; net localgroup &quot;Backup Operators&quot; thmuser1...</div></div></div></a><a class="pagination-related" href="/2025/03/18/Windows%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/" title="Windows权限提升"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-18</div><div class="info-item-2">Windows权限提升</div></div><div class="info-2"><div class="info-item-1">Windows权限提升常见获取密码方式无人值守的 Windows 安装在大量主机上安装 Windows 时，管理员可以使用 Windows 部署服务，该服务允许通过网络将单个操作系统映像部署到多个主机。这些类型的安装称为无人值守安装，因为它们不需要用户交互。此类安装需要使用管理员帐户执行初始设置，最终可能会存储在计算机的以下位置： 12345目录:\无人参与.xmlC:\Windows\Panther\Unattend.xmlC:\Windows\Panther\Unattend\Unattend.xml系统信息文件夹:\Windows\system32\sysprep.infC:\Windows\system32\sysprep\sysprep.xml  作为这些文件的一部分，您可能会遇到凭证： 12345&lt;Credentials&gt;    &lt;Username&gt;Administrator&lt;/Username&gt;    &lt;Domain&gt;thm.local&lt;/Domain&gt;   ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">deCOLE</div><div class="author-info-description">凡夫俗子岂识我，非到末路不甘休</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows%E5%86%85%E9%83%A8"><span class="toc-number">1.</span> <span class="toc-text">Windows内部</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%EF%BC%88Processes%EF%BC%89"><span class="toc-number">1.0.1.</span> <span class="toc-text">进程（Processes）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%EF%BC%88Threads%EF%BC%89"><span class="toc-number">1.0.2.</span> <span class="toc-text">线程（Threads）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%88Virtual-Memory%EF%BC%89"><span class="toc-number">1.0.3.</span> <span class="toc-text">虚拟内存（Virtual Memory）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%88DLL%EF%BC%89"><span class="toc-number">1.0.4.</span> <span class="toc-text">动态链接库（DLL）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E7%A7%BB%E6%A4%8D%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%EF%BC%88Portable-Executable-Format-%EF%BC%89"><span class="toc-number">1.0.5.</span> <span class="toc-text">可移植可执行文件格式（Portable Executable Format ）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8EWindows%E5%86%85%E9%83%A8%E4%BA%A4%E4%BA%92"><span class="toc-number">1.0.6.</span> <span class="toc-text">与Windows内部交互</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/19/TryHackMe%E6%88%BF%E9%97%B4%E4%B9%8BBilling/" title="TryHackMe房间之Billing">TryHackMe房间之Billing</a><time datetime="2025-05-18T16:00:00.000Z" title="发表于 2025-05-19 00:00:00">2025-05-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/19/TryHackMe%E6%88%BF%E9%97%B4%E4%B9%8BEnterprise/" title="TryHackMe房间之Enterprise">TryHackMe房间之Enterprise</a><time datetime="2025-05-18T16:00:00.000Z" title="发表于 2025-05-19 00:00:00">2025-05-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/19/TryHackMe%E6%88%BF%E9%97%B4%E4%B9%8BReset/" title="TryHackMe房间之Reset">TryHackMe房间之Reset</a><time datetime="2025-05-18T16:00:00.000Z" title="发表于 2025-05-19 00:00:00">2025-05-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/18/Python%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/" title="Python原型链污染">Python原型链污染</a><time datetime="2025-03-17T16:00:00.000Z" title="发表于 2025-03-18 00:00:00">2025-03-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/18/Pearcmd%E6%80%BB%E7%BB%93%E5%8F%8A%E5%88%A9%E7%94%A8/" title="Pearcmd总结及利用">Pearcmd总结及利用</a><time datetime="2025-03-17T16:00:00.000Z" title="发表于 2025-03-18 00:00:00">2025-03-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By deCOLE</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>